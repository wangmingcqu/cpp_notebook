记录C++中基础语法以及八股文。



#### 0、C++中的一些基本东西

**1.ASCII表格**

ASCII码表格：

| **ASCII**值 | **控制字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** |
| ----------- | ------------ | ----------- | -------- | ----------- | -------- | ----------- | -------- |
| 0           | NUT          | 32          | (space)  | 64          | @        | 96          | 、       |
| 1           | SOH          | 33          | !        | **65**      | **A**    | **97**      | **a**    |
| 2           | STX          | 34          | "        | 66          | B        | 98          | b        |
| 3           | ETX          | 35          | #        | 67          | C        | 99          | c        |
| 4           | EOT          | 36          | $        | 68          | D        | 100         | d        |
| 5           | ENQ          | 37          | %        | 69          | E        | 101         | e        |
| 6           | ACK          | 38          | &        | 70          | F        | 102         | f        |
| 7           | BEL          | 39          | ,        | 71          | G        | 103         | g        |
| 8           | BS           | 40          | (        | 72          | H        | 104         | h        |
| 9           | HT           | 41          | )        | 73          | I        | 105         | i        |
| 10          | LF           | 42          | *        | 74          | J        | 106         | j        |
| 11          | VT           | 43          | +        | 75          | K        | 107         | k        |
| 12          | FF           | 44          | ,        | 76          | L        | 108         | l        |
| 13          | CR           | 45          | -        | 77          | M        | 109         | m        |
| 14          | SO           | 46          | .        | 78          | N        | 110         | n        |
| 15          | SI           | 47          | /        | 79          | O        | 111         | o        |
| 16          | DLE          | 48          | 0        | 80          | P        | 112         | p        |
| 17          | DCI          | 49          | 1        | 81          | Q        | 113         | q        |
| 18          | DC2          | 50          | 2        | 82          | R        | 114         | r        |
| 19          | DC3          | 51          | 3        | 83          | S        | 115         | s        |
| 20          | DC4          | 52          | 4        | 84          | T        | 116         | t        |
| 21          | NAK          | 53          | 5        | 85          | U        | 117         | u        |
| 22          | SYN          | 54          | 6        | 86          | V        | 118         | v        |
| 23          | TB           | 55          | 7        | 87          | W        | 119         | w        |
| 24          | CAN          | 56          | 8        | 88          | X        | 120         | x        |
| 25          | EM           | 57          | 9        | 89          | Y        | 121         | y        |
| 26          | SUB          | 58          | :        | 90          | Z        | 122         | z        |
| 27          | ESC          | 59          | ;        | 91          | [        | 123         | {        |
| 28          | FS           | 60          | <        | 92          | /        | 124         | \|       |
| 29          | GS           | 61          | =        | 93          | ]        | 125         | }        |
| 30          | RS           | 62          | >        | 94          | ^        | 126         | `        |
| 31          | US           | 63          | ?        | 95          | _        | 127         | DEL      |

ASCII 码大致由以下**两部分组**成：

* ASCII 非打印控制字符： ASCII 表上的数字 **0-31** 分配给了控制字符，用于控制像打印机等一些外围设备。
* ASCII 打印字符：数字 **32-126** 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。



先是大写后是小写。大写字母和小写字母之间差了32位。



#### 1、什么是构造函数与析构函数

- 构造函数：创建对象时为对象的成员属性进行赋值。编译器自动调用，无需手动调用。
- 析构函数：对象销毁前系统自动调用，执行一些清理工作。

==构造函数细节==：

1、没有返回值也不写void

2、函数名称与类名相同

3、构造函数可以**有参数**，因此可以发生重载

4、程序在调用对象时会自动调用构造，无需手动调用，而且只会调用一次

==析构函数细节==

1、没有返回值也不用写void

2、函数名称与类名相同，在名称前加上符号~

3、析构函数**不可以有参数**，因此不可以发生重载

4、程序在对象销毁前会自动调用析构函数，无需手动调用，而且只会调用一次

一般析构函数定义为类的共有成员。

#### 1、构造函数的调用规则

通常情况下，编译器给一个类添加3个函数

- 默认构造函数(无参)
- 默认析构函数(无参)
- 默认拷贝构造函数(对属性进行拷贝)

调用规则如下：

- 如果用户定义有参构造函数，c++不再提供无参构造，但是会提供默认拷贝构造函数
- 如果用于定义了拷贝构造函数，c++不会再提供其他构造函数

优先级就是:     无参->有参->拷贝构造函数，提供了高优先级的就不会再提供低优先级的函数。但是同时也不会再使用低优先级的来初始化对象，如果还使用低优先级的来初始化类的话，还是会报错的。

#### 2、浅拷贝和深拷贝

浅拷贝：简单的赋值拷贝操作，编译器提供

深拷贝：在堆区重新申请空间，进行拷贝操作，由程序员提供。

如果有类中有属性在堆区开辟，一定要自己提供拷贝构造函数，防止浅拷贝出现的问题。



一般情况下，当出现类的等号赋值时，会调用拷贝构造函数，如果没有定义拷贝构造函数，系统会调用默认的拷贝构造函数，这是一个浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。

但是当类的成员中存在指针时，如果采用简单的浅拷贝，则两个类中的指针会由于浅拷贝指向同一个地址。当程序结束的时候，会调用两次析构函数，会导致堆区内存的重复释放问题，造成野指针。



#### 3、一般什么时候会调用拷贝构造函数？

拷贝构造函数必须是引用传递，不能是值传递。

C++中拷贝构造函数的调用时机通常有三种情况。

- 使用一个已经创建完毕的对象来初始化另一个新对象 A a1 = a2;
- 一个对象以值传递的方式传入函数体，需要拷贝构造函数创建一个临时对象压入到栈空间中。void func(const A& a)；
- 一个对象以值传递的方式从函数返回，需要执行拷贝构造函数创建一个临时对象作为返回值

**注意拷贝构造函数的参数传递一定是引用传递。**





#### 4、野指针(wild)和悬空(dangling)指针有什么区别？

**野指针**是指没有被初始化过的指针。⽤ gcc -Wall 编译, 会出现 used uninitialized 警告。

**悬空指针**指最初指向的内存已经被释放了的一种指针。

无论是**野指针**还是**悬空指针**，都是指向**无效内存区域**(指不安全不可控)的指针。访问"不安全不可控"的内存区域将导致"Undefined Behavior"。

**如何避免使用野指针**？ 要养成在定义指针后且使用指针之前**完成初始化**的习惯或者使用**智能指针**。

避免方法：

- 初始化置NULL。
- 申请内存后判定是否为空。
- 指针释放后置为NULL。
- 使用智能指针。

==解析==：

任何指针在被创建的时候，不会自动变成NULL指针，它的default值是随机的。所以比较好的习惯是指针刚创建的时候，要么设置为NULL指针，要么指向合理的内存区域。



#### 5、空指针

==NULL==

**NULL**是一个值为0的宏常量： # define NULL ((void) 0)

意义：通常把NULL赋值给指针，这样就标志该指针为空指针，没有指向任何空间。对指针进行解引用通常能够获得它指向的值。但是从定义上看，NULL指针并未指向任何东西，因此**对一个NULL指针解引用是一个非法的操作**，所以在解引用之前必须先确保他不是一个NULL指针。

==nullptr==

某种意义上，传统C++会把NULL、0视为同一种东西，取决于编译器如何定义NULL，有些编译器会将NULL定义为((void*)0)，有些则会直接定义成0。**C++中不允许直接将 void *隐式转换到其他类型**，但是如果NULL被定义为((void *)0),那么当编译char * ch=NULL时，NULL只好被定义为0，而这依然会产生问题，将导致C++中重载特性发生混乱。考虑：

```cpp
void func(int);
void func(char *);
```

如果 NULL ⼜被定义为了 0 那么 func(NULL) 这个语句将 会去调⽤ func(int)

为了解决这个问题，C++引入了nullptr关键字，专门用来区分空指针和0。nullptr的类型为nullptr_t，**能够隐式的转换为任何指针和成员指针的类型**。

一般情况下使用nullptr。

#### 6、构造函数的调用方法

调用方式：括号法 显示法 和隐式转换法

```cpp
Person p("王明");       //括号法
Person p=Person("王明");//显示法
Person p="王明";        //隐式转换法（使用explicit关键字会禁止这种用法）,使用这种方法进行构造使用的是单参数构造。
// C++是一种强类型的编程语言，不同的数据类型一般是不能进行相互转换的，要想进行类型转换，必须显示的强制类型转换
```



#### 7、类对象作为类成员的构造与析构顺序

```cpp
class A {}
class B
{
    A a；
}
```

B类中有对象A作为成员，A为对象成员。

构造顺序：先调用对象成员的构造，再调用本类的构造

析构顺序与构造顺序相反。

首先调用对象成员的构造再调用本类的构造函数。



#### 8、静态成员

**静态成员函数和静态成员变量都是有访问权限的。**

静态成员：在成员变量和成员函数前加上static，称为静态成员。

分为静态成员变量与静态成员函数。

静态成员变量：（可以应用在比如这个类被实例化了多少个）

*  所有对象共享同一份数据
*  在编译阶段分配内存
*  类内声明，类外初始化  (静态成员函数并不需要在类外进行初始化)   int Person::m_A=10;

静态成员函数：

- 所有对象共享同一个函数
- 静态成员函数只能访问静态成员变量

严格来说，静态成员变量并不属于这个类，只有非静态成员变量才属于这个类。同时，每一个非静态成员函数只会诞生一份函数实例，也就是多个同类型的对象会公用一块代码。也就是说，实例化的多个类的对象都会使用同一份函数。但是这个代码如何知道是哪一个对象调用的自己？答案就是采用this指针。

**this指针**指向被调用的成员函数所属的对象，只能用于类内**非静态成员函数内部**，因为哪一个对象调用他，this指针就指向哪一个对象。静态成员函数严格来说并不属于这个类，可以不经过对象来调用。**this**指针在类的非静态成员函数中返回对象本身。可采用return *this;

==静态成员是所有的对象共享同一份东西，而常函数是每一个对象都拥有一个实例==

#### 9、常函数和常对象

常函数：

- 成员函数后加上const后我们称这个函数为常函数
- 常函数内不可以修改成员属性
- 成员属性声明时加上关键字mutable之后，常函数之内依然可以修改

常对象：

- 声明对象前加const称为该对象为常对象
- 常对象只能调用常函数  (表明这个类中所有的成员属性都是不可以更改的)，不能调用类内其他的函数
- 常对象也不能修改成员属性的值(但是可以访问成员属性的值)，如果成员属性加上mutable,这个则是可以修改的。

普通对象可以调用常函数，但是常对象只能调用常函数。



**mutable关键字作用：**

mutable的中文意思是可变的，易变得。在C++中，mutable是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使是在一个const函数中。

**mutable只能用于修饰类的非静态数据成员。**



#### 10、类的权限相关

内部访问：在类内部定义类函数等操作，访问类的属性或者方法叫做内部访问

外部访问：在类的外部，创建了一个类的实例化对象，通过.操作符或者->操作符来访问类的方法叫做外部访问。

声明为**public的属性与方法，内部与外部均可访问到**；**proteced与private只能在其内部访问**。按照保护程度来排序，应为：private>protected>public

类的初始化列表

```cpp
class Human{
public:
    Human(){
        name = "无名";
        gender = "男";
        age = 0;
    }
    Human(const string&name,const string&gender,int age):name(name),gender(gender),age(age){}
    string name;
    int getAge(){return this->age;}
    string getGender(){return this->gender;}
protected:
    string gender;
private:
    int age;
};
```



#### 10、友元

友元就是让类外的一些特殊函数和类访问到类内的一些**私有属性**。

友元一般有三种实现：

- 全局函数做友元        friend void goodGay(Building * building);
- 类做友元                   friend class goodGay;             //类内创建了类
- 成员函数做友元        friend void goodGay::visit();

也就是另一个类的成员函数



#### 11、运算符重载

为了解决类对象之间的运算。

#### 12、关于类的权限

在类中可以访问自己类的public、protected、private成员，类对象只能访问自己类的public成员(只能通过外部访问)。

```cpp
class Base1
{	//在类内可以访问所有的属性
	void print()
	{
		cout << m_A << endl;
		cout << m_B << endl;
		cout << m_C << endl;
	}

public:
	int m_A;
protected:
	int m_B;
private:
	int m_C;
};

// 在类外只能访问公开属性。访问另外两个属性的话会报错。
Base1 b1;
b1.m_A;
```

#### 12、继承

**1.基本**

class A : public B; 

A 类称为子类 或 派生类

B 类称为父类 或 基类

**派生类中的成员，包含两大部分**：

一类是从基类继承过来的，一类是自己增加的成员。

从基类继承过过来的表现其共性，而新增的成员体现了其个性。







**2.继承方式**

基类的私有成员是绝对不能够访问到的

1.public继承：

==派生类==可以访问基类的public、protected成员，不能访问基类的private成员。

==派生类对象==可以访问基类的public成员，不可以访问基类的protected、private成员。

2.protected继承：

==派生类==可以访问基类的public、protected成员，不能访问基类的private成员。

==派生类对象==不可以访问基类中的任何成员。

3.private继承：

==派生类==可以访问基类的public、protected成员，不可以访问基类的private成员；

==派生类对象==不可以访问基类中的任何成员。



(相比于protected继承，在孙子类中不可以访问任何一个成员)。

子类对象内一定可以访问到基类对象内的protected和private权限的。

继承方式其实限制的是子类类外的访问。



在派生类的类内，一定可以访问到public和protected成员，。





上述内容主要限制的其实是类外的一个访问内容。

继承的方式有三种，这三种继承方式限制的其实主要是类外(包括子类的子类)

- 无论以何种方式继承，父类private的属性在子类中都是不可以访问的。

- 以public的方式来继承父类：

  在子类的类内，只可以访问public和protected的成员。(也就是在子类类内的一些成员函数)

  在子类类外，只能访问父类中public成员                    (通过子类.访问这些属性，也是不可取的),但是可以通过父类中相关函数来访问

- 以protected方式继承：

​		在子类的类内，只可以访问public和protected的成员。

​		在子类类外，所有的属性都不可以访问。

==以上两种方式在孙子类(继承子类的子类)，都可以访问基类中的public和protected成员属性==

- 以private方式继承，子类类内可以访问public和protected，但是在孙子类以及类外，不能访问基类中的任何一个成员。

 

**3.内部模型**

==虽然父类的私有成员在父类中并不能访问到，但是在子类中其实只是被隐藏了，在子类中还是存在的==



**4.子类与父类的构造与析构顺序**

继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反



**5.继承中同名函数处理方法**

1、同名成员处理

同名成员包括同名成员属性和同名成员函数。遵循下面两个原则：

* 访问子类同名成员   直接访问即可
* 访问父类同名成员   需要加作用域

代码示例

```cpp
class Base{
  public:
    Base();
    void func();        // 某个函数
    void func(int a);   // 与上面函数互为重载关系
    int m_A;            // 在构造函数中已经进行了赋值操作
};

class Son:public Base{
public:
    Son();
    void func();    // 与父类中的函数相同
    int m_A;        // 与父类中的函数相同
};
//1、访问同名成员属性
Son s;
cout<<s.m_A<<endl;          //子类中的成员
cout<<s.Base::m_A<<endl;    //父类中的成员

//2、访问同名成员函数
s.func();                  //访问子类中的成员
s.Base::func();            //访问父类中的成员函数
s.Base::func(10);          //访问父类中的重载的成员函数

```

2、同名静态成员处理方式

```cpp
class Base{
public:
    static void func();
    static void func(int a);
    static int m_A;
};
int Base::m_A = 100;//静态属性需要在类外进行赋值

class Son:public Base{
public:
    static void func(); //静态成员函数
    static int m_A;     //静态成员变量
}
int Son::m_A=200;
// 1、访问同名成员属性
// 1.1通过对象访问
Son s;
cout<<s.m_A<<endl;
cout<<s.Base::m_A<<endl;
// 1.2通过类名访问
cout<<Son::m_A<<endl;
cout<<Son::Base::m_A<<endl;//与下面一种方式等价
cout<<Base::m_A<<endl;

// 2、访问同名成员函数
// 2.1 通过对象访问
Son s;
s.func();
s.Base::func();

// 2.2 通过类名进行访问
Son::func();
Son::Base::func(100);//与下面那一张方式等价
Base::func(100);
```



**6、多继承**

在实际中一般不建议使用多继承语法，极有可能出现各种问题。

在C++中一个类可以继承多个类，

语法:

class 子类:继承方式 父类1， 继承方式 父类2...

//多继承容易产生成员同名的情况
//通过使用类名作用域可以区分调用哪一个基类的成员



**7、菱形继承**

两个子类继承了同一个基类，同时，又有一个孙子类继承了两个子类。这种继承方式称为菱形继承以及钻石继承。

* 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义
* 利用虚继承可以解决菱形继承问题

虚继承与虚基类

```cpp
class Animal
{
public:
	int m_Age;
};

//继承前加virtual关键字后，变为虚继承
//此时公共的父类Animal称为虚基类
class Sheep : virtual public Animal {}; //在继承的前面也加上virtual
class Tuo   : virtual public Animal {}; 
class SheepTuo : public Sheep, public Tuo {};


SheepTuo st;
// 由于是虚继承，所以下面两个操作作用的是同一个变量
st.Sheep::m_Age = 100;
st.Tuo::m_Age = 200;

// 以下两个输出的都是200
cout << "st.Sheep::m_Age = " << st.Sheep::m_Age << endl;
cout << "st.Tuo::m_Age = " <<  st.Tuo::m_Age << endl;
cout << "st.m_Age = " << st.m_Age << endl;
```

#### 13、多态

主要是针对继承导致的成员函数。

==可以理解为让不同的对象出现不同种类的行为==。

==不同类型的对象，去完成同一件事，产生的动作是不一样的。==



​		如果我们想让基类中的某个函数在不同的子类中有不同的实现，那么就将基类中的这个函数设置为虚函数，再让子类重写这个函数，但是同时如果我们又不想实例化基类对象的话，我们可以将基类中的函数设置为纯虚函数，通过这种方式，说明这个基类不能实例化对象。

​		多态其实就是不同的类继承基类，基类中存在一个函数，但是我们每一个子类调用这个函数的时候想根据自己类的特性而改变这个函数内部实现。因此我们在子类中就可以**重写（函数返回值类型、函数名、参数列表）**这个函数。将基类中的这个函数变成加上virtual变成虚函数。变成虚函数之后就不能去确定是哪一个函数进行调用了。这样做得好处就是，我们可以直接用基类来接收子类，也即是用父类的对象或者引用来接收子类对象，然后执行这个对象的函数的时候就会根据传入的子类对象类型执行子类中不同的重写的函数。



**1、基本概念**

多态分成两类：

- 静态多态：函数重载和运算符重载属于静态多态，复用函数名
- 动态多态：**派生类和虚函数实现运行时多态**

静态多态和动态多态：

- 静态多态的函数地址早绑定- 编译阶段确定函数地址。  (编译期多态)
- 动态多态的函数地址晚绑定， 运行阶段确定函数地址。



动态多态是根据虚函数进行实现的。



下面的其实是动态多态的满足条件。

多态满足条件：
1、有继承关系
2、子类重写父类中的虚函数

多态使用：
父类指针或引用指向子类对象   (父类指针和引用也是可以指向自己的)

==重写：重写和重载是不一样的，函数返回值类型，函数名，参数列表完全一致称为重写==

==虚函数：在类内成员函数中加入virtual关键字，就变成虚函数，那么编译器在编译的时候就不能确定函数调用了==



而重载，指相同作用域中被声明的几个具有不同参数列表(参数的类型、个数和顺序)的同名函数，根据参数列表确定调用哪一个函数。重载不关心函数返回类型，不能够依靠函数返回类型来进行判断。







**2、纯虚函数**

通过上面可以知道，如果一般我们不实例化基类对象的话，那么这个基类的虚函数基本上就没有意义，一般都是要调用子类的对象。因此，我们可以将虚函数变成纯虚函数。也就是

virtual 返回值类型 函数名()=0;

如果某一个类中有了纯虚函数，那么我们就称之为抽象类。

抽象类会存在以下特点：

- 无法实例化对象
- 子类必须要重写父类中的纯虚函数，否则也就是抽象类，抽象类是无法实例化对象的。

==加上了纯虚函数说明在子类中必须要重写这个纯虚函数，否则一定会报错。而基类中的虚函数则不是一定要的==



**3、虚析构与纯虚析构**

在子类中，如果有属性开辟到了堆区(也就是有成员属性是指针)。在执行多态的时候，一般情况下式先运行父类的构造函数，再执行子类的构造函数，然后执行子类的析构函数，最后执行父类的析构函数。但是如果存在多态的话，由于我们用了父类的指针或者引用接受了子类对象，因此最后析构的时候，只会执行父类的析构函数，子类的析构函数压根不会调用。因此如果子类的成员存在开辟堆区的话，通过父类的析构函数并不会被释放。

==父类指针在析构的时候，并不会调用子类的析构函数，子类中如果有堆区属性，就会出现内存泄露==

**解决方法：**将父类中的析构函数改为**虚析构**或者**纯虚析构**



虚析构和纯虚析构共性：

* 可以解决父类指针释放子类对象
* 都需要有具体的函数实现

虚析构和纯虚析构区别： 如果是纯虚析构，该类属于抽象类，无法实例化对象

虚析构语法：

`virtual ~类名(){}`

纯虚析构语法：

` virtual ~类名() = 0;`

`类名::~类名(){}`   //这个函数任然是会运行的，所以也是要给出的。

加上虚析构让子类也运行。

**加上了虚析构和纯虚析构之后，就可以运行子类的析构函数了，注意：父类的析构函数也会继续进行运行。**其实虚析构和纯虚析构就是为了解决子类函数中的析构函数无法进行调用的问题。

总结：

​	1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象

​	2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构

​	3. 拥有纯虚析构函数的类也属于抽象类



将父类中的析构函数改成虚析构或者纯虚析构

#### 14、函数重载

**函数重载满足条件：**

* 同一个作用域下
* 函数名称相同
* 函数参数**类型不同**  或者 **个数不同** 或者 **顺序不同**

==重写：重写和重载是不一样的，函数返回值类型，函数名，参数列表完全一致称为重写==

函数返回值不同不是函数重载的条件之一。



#### 15、内存泄露

内存泄露就是申请了一块内存空间，使用完毕之后没有释放掉。一般表现就是程序运行时间越长，占用内存越多，最终用尽全部内存，使得整个系统崩溃。用new分配的内存，一定要在适当的时候使用delete释放内存。



#### 16、c++中的智能指针



#### 17、分配堆区内存

1、new/delete是操作符，malloc/free 是库函数。

2、new输入的是一个类型值，所以他做了两件事，一是在**堆区申请了内存，二调用了类的构造函数初始化这块内存**。而delete则是**一调用该类的析构函数**，**二是释放该堆区申请的内存**，而malloc和free只是分配和释放内存，仅仅是释放了这个对象所占的内存，而不会调用这个对象的析构函数。

3、new建立的是一个对象，而malloc分配的是一个内存。new出来的对象就是一个带有类型的指针，而malloc的是void指针，需要进行转换。

```cpp
// 申请一个int类型的指针，并且将10赋值给该指针指向的值。
int * p = new int(10);
delete p;

// 给数组申请一块内存
int * arr = new int[10];
delete[] arr;//删除数组的时候一定要加上中括号
```

使用mallo

```cpp
//mallo在c++中其实是一个函数
//函数原型为： 
void* malloc(size_t size);// 输入的是字节的个数。
//其中，参数size_t size指定需要分配的内存大小（以字节为单位），函数返回值为void*类型的指针，指向分配的内存块的起始地址。
int* p = (int*)malloc(sizeof(int*));//返回的是void*指针，需要将其转换成int*指针
free(p);//使用free来进行释放
```



#### 18、函数模板和类模板

C++的另一种编程思想称为泛性编程，C++中提供两个模板机制(函数模板和类模板)

==函数模板：==

**1、使用方法**

```cpp
//利用模板提供通用的交换函数
template<typename T>    //或者template<class T>
void mySwap(T& a, T& b) //函数模板中一般传入参数就是模板。
{
	T temp = a;
	a = b;
	b = temp;
}
//1、自动类型推导，不能发生隐式类型转换，普通函数则可以。不要指定函数类型，就相当于普通函数一样
int a,b;
mySwap(a, b);
//2、显示指定类型，显示指定类型之后，就像普通函数一样，则可以进行隐式类型转换。也即是如果输入不是Int类型的数据，会将其准换成int类型的数据
mySwap<int>(a, b);

```

注意事项：

* 自动类型推导，必须推导出一致的数据类型T,才可以使用


* 模板必须要确定出T的数据类型，才可以使用

**2、普通函数和函数模板的区别**

- 普通函数调用时可以发生自动类型转换（隐式类型转换）。
- 函数模板调用时，如果用自动类型推导，则不会发生隐式类型转换。
- 如果利用显示指定类型，则可以发生隐式类型转换。

**3、函数模板的调用规则**

- 如果函数模板和普通函数都可以实现，优先调用普通函数
- 通过空模板参数列表可以强制调用函数模板
- 函数模板也可以发生重载
- 如果函数模板可以产生更好的匹配，优先调用函数模板。

==类模板：==

**1、使用方式**

```cpp
template<class NameType, class AgeType> 
class Person{};
Person<string, int> p("孙悟空"，100)；
```

**2、类模板和函数模板的区别**

类模板与函数模板区别主要有两点：

1. 类模板没有自动类型推导的使用方式
2. 类模板在模板参数列表中可以有默认参数(也即是必须要显示指定类型)

```cpp
template<class NameType, class AgeType = int> 
class Person{}；
```



**3、类模板中成员函数的创建时机**

类模板中成员函数和普通类中成员函数创建时机是有区别的：

* 普通类中的成员函数一开始就可以创建
* 类模板中的成员函数在调用时才创建



**4、类模板与继承**

当类模板碰到继承时，需要注意一下几点。

- 当子类继承的父类是一个类模板的时候，子类在声明的时候，要指出父类中T的类型。如果不指定，编译器就无法给子类分配内存。
- 因为子类并不是一个类模板，如果将子类也变成一个类模板，则可以规避掉这种问题。



**5、类模板成员函数类外实现**

类模板中成员函数类外实现时，需要加上模板参数列表

```cpp
template<class T1,class T2>
class Person{
  public:
  Person(T1 name,T2, age);
  T1 m_name;
  T2 m_age;
};
//成员函数类外实现，也会加上参数列表
template<class T1,class T2>
Person<class T1, class T2>::Person(T1 name, T2 age){
    this->m_name = name;
    this->m_age = age;
}
```



#### 19、STL容器

stl六大组件：**容器** 、**算法** 、**迭代器**、 **仿函数** 、**适配器** 、**空间配置器**

1. 容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。
2. 算法：各种常用的算法，如sort、find、copy、for_each等
3. 迭代器：扮演了容器与算法之间的胶合剂。
4. 仿函数：行为类似函数，可作为算法的某种策略。
5. 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。  比如STL中的stack和queue并不是所谓的容器，而是容器适配器，但是其封装了其他容器，修饰其接口以满足自身逻辑结构的需要。
6. 空间配置器：负责空间的配置与管理。

栈(stack)和队列(queue)：分别使用vector和deque来实现，提供了后进先出和先进先出的操作。

容器分为序列时容器与关联式容器：

**序列式容器：**强调值的排序，序列式容器每一个元素均有固定的位置  Vector Deque List

**关联式容器：**二叉树结构，各元素没有严格的物理上的顺序关系。 Set/Multiset  Map/Multimap



序列式容器添加值的时候一般使用push

关联式容器添加值的时候一般使用insert



**1、string字符串**

string 的重点是要记住string的查找和替换以及子串，做题中经常会处出现使用这种方法的函数。

```cpp
/*1、string的构造*/
# include<string>
//1.1
string s1;  //创建空字符串
//1.2 利用char*类型字符串构造
const char* str = "hello world";
string s2(str);
//1.3 利用string类型的字符串构造
string s3(s2);
//1.4 利用char类型的字符来构造
string s4(10, 'a');



/*2、string赋值*/
//2.1 char*类型的字符串直接等于
string str1;
str1 = "hello world";

//2.2 string类型的字符串
string str2;
str2 = str1;

//2.3 char 类型的字符串
string str3;
str3 = 'a';

//2.4 assign通过char*
string str4;
str4.assign("hello c++");

//2.5 assign通过char*,而且还有限制
string str5;
str5.assign("hello c++",5);//将输入字符串的前5个字符赋给当前的字符串
    
//2.6 assign通过string
string str6;
str6.assign(str5);

//2.7
string str7;
str7.assign(5,'x');  //将5个字符x赋值给当前字符串


/*3、字符串拼接*/
//3.1 重载+运算符(char *)
string str1 = "我";
str1 +="爱玩游戏";

//3.2 重载+运算符(char)
str1 += ';';

//3.3 重载+运算符(string)
string str2 = "roral way";
str1+=str2;

//3.4 重载append运算符(char*)
string str3 = "I";
str3.append(" love ");

//3.5 重载append运算符(char *, n)(把字符串的前n个字符连接到当前字符串结尾)
str3.append("slmm tt",4);

//3.6 重载append运算符(char *, pos, n) (字符串s中从pos开始的n个字符连接到字符串结尾)
string str = "wm slmm tt"
	//下面两种方式等价
str3.append(str,7,3);
str3.append("wm slmm tt", 7, 3);//向其中添加了" tt"


/*4、查找和替换 find and rfind and replace*/ 
//4.1 查找第一次出现某一个字符串的位置，如果查找不到，则返回-1
string str1 = "abcdefgde";
int pos = str1.find("de");   // 第一次出现"de"的位置，返回3

//4.2 查找最后一次出现某一个字符串的位置，如果查找不到,则返回-1
pos = str1.rfind("de");     //返回7

//4.3 replace(int pos, int n, char*s) 在原字符串中替换从pos开始的n个字符到字符串中
//这个函数比较重要，相当于python中切片之后再进行赋值。
string str1 = "abcdefgde";
str1.replace(1, 3, "2222");// 替换原字符串中从1开始数的前三个字符串，返回"a2222efgde"

/*5、字符串比较*/

// 字符串比较是按字符的ASCII码进行对比
string s1 = "hello";
string s2 = "aello";
int ret = s1.compare(s2);//等于0则表示两者相同

/*6、字符串存取*/
string str = "hello world";
cout<<str[3]<<endl;
cout<<str.at(3)<<endl;

//修改，如果需要修改多个的话，则需要用到前面的replace，通过下面的方法只能修改一个字符串。
str[0] = "x";
str.at(1)= "x";

/*7、插入和删除*/
//7.1 str.insert(int pos, char* s)   从某个位置开始，插入某个字符串和字符
string str = "hello";
str.insert(1, "1111");  // "h1111ello"
//7.2 str.erase(int pos, int n)  在原字符串中，删除从pos开始的n个字符
str.erase(1, 3);        // "h1ello"

/*8、子串*/
str.substr(int pos, int n) //在字符串中，获得从pos开始的n个字符串
```

```cpp
// 1.string
// str.substr(int pos, int n)               索引：从pos开始取n个子串
// str.replace(int pos, int n, char* s)     替换：替换str中从pos开始往后的n个字符为字符串s
// str.insert(int pos, char* s)             插入：在str中，从位置pos开始往后插入字符串s
// str.erase(int pos, int n)                删除：在str中，删除从pos开始的n个字符//和子串差不多
// int pos = str.find(char* s or char)      查找：查找第一次出现字符串或者字符的位置(是索引)
// int pos = str.rfind(char* s or char)     查找：查找最后一次出现字符串或者字符的位置(是索引)

// 2.vector 只有尾插和尾部删
// vector<vector<int>> dp(m,vector<int>(n)); 构造：构造二维数组，构造二维矩阵
// vecror<int> ve(v.begin(), v.end())        切片：将v容器中v.begin(), v.end()之间的位置赋值给ve，左闭右开
// vecror<int> ve(v)                         构造：拷贝构造函数
// vecror<int> ve(int n, ele=0)              构造：将n个元素赋值给自身,默认将0赋值给本身

// ve.assign(beg, end)                       赋值：将[beg,end)区间的元素赋值给ve,beg与end是迭代器
// ve.assign(int n, ele)                     赋值：将n个ele赋值给本身，会覆盖掉之前的
// ve.empty()                                判断：判断是否为空， 为空则返回1, 不为空则返回0
// int s = ve.size()                         容量：返回容量，确切叫元素个数。
// ve.resize(int n)                          容量：指定容量。容器加长，默认位置填充；容器变短，删除超过部分。
// ve.resize(int num, ele)                   容量：指定容量。容器变成，指定以ele填充。
// int s = ve.capacity()                     容量：真正的最大容量。

// v.push_back(ele)                          尾插
// v.pop_back()                              尾删
// v.insert(const_iterator pos, ele)         插入：在迭代器位置插入ele
// v.insert(const_iterator pos, int n, ele)  插入：迭代器指向位置pos插入n个元素ele
// v.erase(const_iterator pos)               删除：删除迭代器指定位置。
// v.erase(const_iterator start, const_iterator end) 删除：删除迭代器从start到end之间的元素
// v.clear();                                删除：删除容器中所有元素

// 数据存取
// v.at(int idx)                             索引：
// v[i]                                      索引：
// v.front()                                 索引：返回第一个元素
// v.back()                                  索引：返回最后一个元素

// 互换容器
// ve.swap(v)                                元素互换
// v.reserve(int len)                        预留空间:减少vector在动态扩展时的扩展次数

// deque容器，双端数组,插入速度快，访问速度可能比较慢
// 1、构造
// deque<int> dq;                            创建：创建容器
// deque<int> dp2(beg, end)                  创建：通过迭代器来构造
// deque<int> dp(n, ele)                     创建：将n个元素拷贝给自身
// deque<int> dq2=dq;                        创建：直接调用拷贝构造函数(不是赋值，而是隐式转换法赋值类)


// 2、赋值
// deque<int> dq;
// dq=dq2;                                   赋值：这里才是赋值，注意要和上面拷贝构造进行区分
// deque<int> dq;
// dq.assign(beg, end);                      赋值：通过迭代器进行赋值
// dq.assign(n, ele);                        赋值：

// 3、容量
// dq.empty();                               判断：判断
// dq.size();                                个数：容器中元素个数
// dp.resize(int num)                        指定容量：变长，以默认值填充；变短，删除元素
// dp.resize(int num, ele)                   指定容量：变长，以ele填充

// 4、插入
// 4.1、两端插入
// dq.push_back(ele);                        尾插：
// dp.push_front(ele);                       头插：
// dp.pop_back();                            尾删：
// dp.pop_front();                           头插：

// dp.insert(pos, ele)                       插入：注意插入的是迭代器
// dp.insert(pos,n,ele)                      插入: 插入n个元素
// dp.insert(pos,beg,end)                    插入：在[beg,end)区间的数据，无返回值
// dp.clear();                               清空容器中所有元素
// dp.erase(beg,end);                        删除[beg,end)区间的数据
// dp.erase(pos);                            删除pos位置的数据，返回下一个数据的位置                           

// 5、数据存取
// dq.at(int i);
// dq[int i];
// dp.front();                              数据：返回容器中的第一个数据元素
// dp.back();                               数据：返回容器中最后一个数据元素


// stack栈，先进后出，不允许有遍历行为 ,能利用的只有栈顶
// stack<int> s;
// s.push();                                增添：向其中增添数据
// s.pop();                                 移除：从栈顶移除第一个元素
// s.top();                                 获取：获取栈顶元素

// s.empty()                                判断堆栈是否为空
// s.size()                                 获得容量 


// queue容器，没有迭代器，遍历该容器，只能用遍历，不能用迭代器，双端数组是有迭代器的
// queue<int> q;
// q.push(ele);                             增添
// q.pop();                                 删除队首元素
// q.back();                                获取最后一个元素
// q.front();                               获取第一个元素
// q.empty();                               判断是否为空
// q.size();                                元素个数
// 普通queue是没有q.top()的，因为队列是双头的，因此用队头和队尾来替代了

// priority_queue, 头文件也是直接导入queue容器 # include<queue>
// priority_queue<int> q;
// q.push(ele);                             增添：元素入列
// q.pop();                                 删除：队首元素出列(也即是优先级最高的元素出列)
// q.top();                                 访问：访问优先级最高的元素(只有优先队列才有)
// q.empty();                               判断队首元素是否为空
// q.size();                                容量：获取元素个数

    
// list容器,双向循环列表，迭代器只支持前移和后移，所需要的空间以及遍历的时间都比较大，适合插入和删除
// 1、构造
// list<int> l1;
// list<int> l2(l1.begin(),l2.begin());     构造：
// list<int> l2(int n, ele)                 构造：将n个元素赋值给自身
// list<int> l3(l2);                        构造：拷贝构造
    
// 2、赋值和交换
// l2.assign(beg,end);                      赋值：迭代器中元素赋值
// l2.assign(n, ele);                       赋值：n个元素拷贝给自身
// l2.swap(l1);                             交换：
  
// 3、大小操作
// n=l1.size()                               容量
// l1.empty();                               容量：判断容量是否为空
// l1.resize(num);                           容量：重新指定容器的长度
// l1.resize(num, ele);                      容量：重新指定容器的长度并且提供默认值

// 4、插入和删除
// l1.push_back(ele)                         插入：尾插
// l1.pop_back();                            删除：尾删
// l1.push_front(ele);                       插入：头插
// l1.pop_front();                           删除：头删
// l1.insert(pos,ele)                        插入：pos是迭代器，无返回值
// l1.insert(pos,beg,end)                    插入：在pos位置
// l1.clear();                               移除容器中所有的元素
// l1.erase(beg,end)                         删除：删除区间的元素
// l1.erase(pos)                             删除
// l1.remove(ele);                           删除list中所有与ele相匹配的
    
    
// 5、数据存取
// l1.front()                               获取：获取第一个元素
// l1.back()                                获取：获取最后一个元素
    
// 6、反转和排序
// l1.reverse();                            反转
// l1.sort()                                反转：默认重小到大
// l1.sort(greater<int>())                  反转：从大到小
    

// set容器,关联式容器，插入数据只能用insert 插入时自动排序，不允许有重复元素
//  1.1 从低到高，依次输出
// set<int> s1;
// set<int> s2(s1); // 拷贝构造

// 1.2大小和交换
// s1.size()                               容量：元素个数
// s1.empty()                              容量：判断容器是否为空
// s1.swap(s2)                             交换

// 1.3插入和删除
// s1.insert(ele)                          插入：插入元素
// s1.clear()                              清空所有的元素
// s1.erase(pos)                           删除迭代器pos指定的元素，返回下一个元素的迭代器
// s1.erase(beg,end)                       删除[beg,end)区间指定的元素
// s1.erase(ele)                           删除容器中值为elem的元素
    
// 1.4查找和统计
// s1.find(key)                            查找key元素是否存在，存在，返回迭代器，不存在，返回set.end()
// s1.count(key)                           统计key元素的个数，就为1或者0 
    
// set和multiset的区别
// multiset可以插入重复数据
// set插入数据时会返回插入结果，表示是否插入成功
// multiset不会检测

// pair
multiset<int, greater<int>> s1;     //指定大的在前面
pair<type, type> p(value1, value2); //无=
pair<type, type> p = make_pair(value1,value2);
p.first  //访问第一个元素
p.second // 访问第二个元素
    
// map容器
// map容器中所有的元素都是pair，所有的元素都会根据元素的键值自动排序,map容器其实和
map<int,int> m;
m.insert(pair<int,int>(1,10));
m.insert(pair<int,int>(2,20));
// 1.1 构造
map<int,int> m2(m);

//1.2大小和交换
// int n= m.size();                        容量：容器中元素个数
// m.empty()                               容量：判断是否为空
// m.swap(m2);                             容量：交换两个容器中的值

// 1.3插入和删除
// m.insert(elem);                         插入：向容器中插入元素 注意是pair类型的
// m.clear();                              删除：清空所有的元素
// m.erase(pos)                            删除：删除迭代器所指的元素，返回下一个元素迭代器
// m.erase(beg,end);                       删除：删除区间[beg,end) 的所有元素，返回下一个元素的迭代器
// m.erase(key);                           删除：删除元素中值为key的元素(这个比较重要，要记住)

//这两个很重要
// m.find(key)                             查找：若存在，返回该元素的迭代器(pair元素迭代器)
// m.count(key)                            查找：统计key元素的个数


// unordered_set容器(内部不会是有序的)
// 比较常用的容器
#include<unordered_set>
std::unordered_set<int> set;
// 插入
set.insert(2);
set.insert(3);
// 删除
set.erase(3);
// 查找
if (set.find(8) == set.end()) {
    std::cout << "没有这个元素" << std::endl;
    }
```

STL用到的其他容器以及索引

```cpp
// 1、
std:: vector<int>::iterator it = std::max_element(nums.begin(), nums.end());// 返回最大元素所在位置的迭代器
int index1 = std::distance( it, nums.begin());// -2
int index1 = std::distance(nums.begin(),it);  // 2(最大元素所在的索引)
```







#### 20、函数对象

重载**函数调用操作符()**的类，其对象称为**函数对象**，由于其行为类似于函数调用，也称为仿函数

函数对象的特点：

- 函数对象在使用时，本质上是调用了类中重载的函数，因此像普通函数那样，可以有参数，也可以有返回值。
- 函数对象超出普通函数的概念，函数对象可以有自己的状态。(比如每运行一次函数，内部状态就加1)
- 函数对象可以作为参数进行传递。

#### 21、谓词

谓词一定是一个类，这个类重载了函数调用操作符。

返回bool类型的仿函数称为**谓词**

根据operator()接受的个数，接受的个数，分为一元谓词和二元谓词

```c++
# include<functional>
# include<algorithm>
// 自定义谓词
class compare {
public:
	bool operator()(int x, int y)  // 有时候后面可以加上const
	{
		return x > y;
	}
};

// 函数
bool compare2(int x, int y)
{
	return x > y;
}

// 下面两种方法等价
// 下面都是函数中,在函数中仿函数可能要加上括号
// 第一个和第二个本质上是利用类名+(),单纯用类名的话只是说调用这个类，但是类名加上括号表示调用这个类中重载的符号
sort(v.begin(), v.end(), greater<int>());  // 注意都是有括号的
sort(v.begin(), v.end(), compare());       // 自己建造的函数对象需要加上括号，表示一个匿名对象

sort(v.begin(), v.end(), compare2)         // 自己建造的函数则不需要加上括号，相当于传入的是一个匿名对象
```

下面是利用匿名函数实现谓词。

```cpp
class Person {
public:
	Person(std::string name ,int age):name(name),age(age){}
	std::string name;
	int age;
};
Person p1("wangming", 23);
Person p2("shaolin", 20);
Person p3("zaizai",5);
std::vector<Person> v;
v.push_back(p1);
v.push_back(p2);
v.push_back(p3);
for (auto x : v) {
	std::cout << x.name << std::endl;
}
//利用自定义的数据类型实现排序
std::sort(v.begin(), v.end(), [](Person p1, Person p2) {return p1.age < p2.age; });
for (auto x : v) {
	std::cout << x.name << std::endl;
}
```



一般情况下不要忘记添加const属性。

下面是利用优先队列 priority_queue

```cpp
// 1、int类型的数值
# include<queue> // 优先队列 queue  可以存在相同的数值
// 通过仿函数来设置优先级，int类型的，值越大优先级越大
// 可以通过自己设置，越小优先级越大
class compare{
  public:// 注意这里一定要设置成public的形式
    bool operator() (int x, int y)
    {
        return x>y;
    }
};
priority_queue<int, vector<int>, compare> pq;      // 默认就是使用vector容器(中间表示使用的容器类型)
priority_queue<int, vector<int>, greater<int>> pq; // 这里都没有括号 

// 2、自定义数据类型
struct NumIndex {
public:
    int val;
    int index;
    bool operator < (const NumIndex& rs) const {//必须要重载<运算符，用于内部进行判断，否则会进行报错
        //因为内部必须要判断优先级
        return val < rs.val;//重载运算符，
}
int main()
{
    priority_queue<NumIndex> q;
	NumIndex ele = { 5,2 };
    q.push(ele);
}
```

下面是set利用自定义数据类型

```cpp
两种方法都需要将重载的运算符设置为常函数
// 1、在类内提供重载"<"运算符，因为其本身就是通过小于运算符进行排列的
class Person {
public:
	Person(string name, int age)
	{
		this->name = name;
		this->age = age;
	}
	bool operator< (Person p2) const  //这里重载的并不是函数调用运算符，而是小于运算符
	{
		return age < p2.age;
	}
	string name;
	int age;
};
Person p1("刘备",32);
Person p2("关飞", 34);
Person p3("张宇", 30);
set<Person> s;
s.insert(p1);
s.insert(p2);
s.insert(p3);

// 2、在类外提供重载"()"运算符
class Person {
public:
	Person(string name, int age)
	{
		this->name = name;
		this->age = age;
	}
	string name;
	int age;
};

class compare { //比较里面的函数需要设置成常函数才行
public:
	bool operator() (Person p1,  Person p2) const // 这个const必不可少
	{
		return p1.age < p2.age;
	}
};

Person p1("刘备",32);
Person p2("关飞", 34);
Person p3("张宇", 30);
set<Person, compare> s;     //这里需要将仿函数提供
s.insert(p1);
s.insert(p2);
s.insert(p3);
```

下面是利用map容器，改变map容器的排序规则

```cpp
// 1、直接利用内置的函数模板其实就可以
map<int, int, greater<int>> m;

// 2、自己写仿函数
class compare2 {
public:
	bool operator() (int x, int y) const   //注意后面的const一定不要忘记添加
	{
		return x > y;
	}
};
map<int, int, compare2> m;
m.insert(make_pair(10, 100));
m.insert(make_pair(30, 200));
m.insert(make_pair(20, 300));
```

#### 22、常用的算法

下面记录一些常用的算法，常用的函数对象(比如谓词等，需要自己提供)

```c++
// 1、常用遍历算法
for_each(iterator beg, iterator end, _func);//_func为函数或者函数对象, 函数对象需要加括号，函数不需要加
transform(iterator beg1, iterator end1, iterator beg2, _func);//转换时可以赋予某些属性



// 2、常用查找算法
// 查找v指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()
find(iterator beg, iterator end, value); 
// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置
find_if(iterator beg, iterator end, _Pred)
// 统计元素个数
int m=count(iterator beg, iterator end, value);
// 统计满足条件的元素的个数 _Pred是bool类型谓词
count_if(iterator beg, iterator end, _Pred);

// 3、排序
// 0、排序
sort(iterator beg, iterator end, _Pred);
// 1、洗牌  指定范围内的元素随机调整次序
random_shuffle(iterator beg, iterator end)
// 2、合并 两个容器合并，并存储到另一个容器中 两个容器必须是**有序的**
merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);
// 3、反转，将容器中的元素进行反转。
reverse(iterator beg, iterator end);// 这个比较简单的一定需要记住

// 4、求解容器之间的交集、并集、差集
// 4.1.求解交集，返回目标容器的最后一个元素的迭代器地址
set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)
// 4.2.求解并集，
set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);
```



#### 23、C++中左值引用与右值引用

[]: 一文读懂C++右值引用和std::move-腾讯技术工程的文章-知乎

左值与右值定义：

**左值：**左值可以取地址，位于等号左边

**右值：**右值无法取地址，位于等号右边

总结：引入右值引用，是因为有些函数并不能接受右值(临时变量，加入const可以接受但是又不能进行更改)，加入右值可以使得函数可以接受临时变量同时在函数内部又可以更改该右值。而右值函数又不能接受左值，所以需要std::move将左值抓换成右值。实现移动构造的话使用右值更加方便。



**1.为什么有右值引用**

注意不添加引用是可以接受临时变量的

```cpp
void te(int a) {
	std::cout << a << std::endl;
}
te(6);// 这样也是合法的操作
```

```cpp
// 函数参数列表中加入了引用的话是不能添加临时变量的，但是如果没有添加引用的话，是不会存在问题的。
// 1.方式1
void change(int& left_value) {
	left_value = 8;
}
int a=6;
change(a);// 将值改成6
//change(6);// 会报错(函数参数列表是一个左值引用，无法接受右值)

// 2.方式2
void change(const int& left_value) {
    // right_value = 8;//会报错
	std::cout<<left_value<<std::endl;
}
change(6);// 不会报错但是在函数内部无法进行更改参数值，因为添加了const

// 3.方式3
void change(int&& right_value) {
	right_value = 8;
	std::cout << right_value << std::endl;
}
change(6);// 不会报错，正常运行。
//change(a);// 会报错，右值引用无法接受左值
change(std::move(a));//std::move将左值强制转换成右值，让右值引用可以指向左值，等价于static_cast<T&&>(lvalue)，此时std::move(a)是右值。

int a = 6;
int&& right_value = std::move(a);
// change(right_value);//会报错。此时right_value是左值。
// std::move(a)返回的既可以是左值也可以是右值。
```



**2.std::move**

std::move其实就是将一个左值转换成右值，使得右值引用能够接受这个左值。

右值引用和std::move被广泛用于在STL和自定义类中实现**移动语义**、**避免拷贝（复制数据）**、**从而提升程序性能**

在C++中，使用赋值操作符或拷贝构造函数时，通常会进行深拷贝，即将一个对象的内容完全复制到另一个对象中。对于包含大量数或动态分配资源的对象，深拷贝会消耗大量的时间和内存，同时会降低程序的性能。

**std::move本身只做类型转换，对性能无影响。** **我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和std::move的语言特性。**

```cpp
// 首先定义一个自定义的类
class Array {
public:
    Array(int size) : size_(size) {
        data = new int[size_];
    }
     
    // 深拷贝构造
    Array(const Array& temp_array) {
        size_ = temp_array.size_;
        data_ = new int[size_];
        for (int i = 0; i < size_; i ++) {
            data_[i] = temp_array.data_[i];
        }
    }
     
    // 深拷贝赋值
    Array& operator=(const Array& temp_array) {
        delete[] data_;
 
        size_ = temp_array.size_;
        data_ = new int[size_];
        for (int i = 0; i < size_; i ++) {
            data_[i] = temp_array.data_[i];
        }
    }
    // 移动构造实现方式1
    // 移动构造函数(相当于霸占了资源，并将原宿主置空)
    Array(const Array& temp_array, bool move) {
        data_ = temp_array.data_;
        size_ = temp_array.size_;
        // 为防止temp_array析构时delete data，提前置空其data_     
        temp_array.data_ = nullptr;// 这一行会报错
    }
    /*这种方法实现移动构造存在两个问题
    1.需要一个额外的参数
    2.const左值引用，因此temp_array.data_ = nullptr会报错，但是如果不添加const的话，又不能接受右值。Array a = Array(Array(), true)这样又会报错
    */
    
    // 移动构造实现方式2(通过右值引用实现移动构造)  移动构造函数与之类似
    Array(Array&& temp_array) {
        data_ = temp_array.data_;// 霸占了原有的数据指针(无需再拷贝原有类中的数据)
        size_ = temp_array.size_;
        // 为防止temp_array析构时delete data，提前置空其data_      
        temp_array.data_ = nullptr;//存在const的话这一行的存在就会报错。
    }
    ~Array() {
        delete[] data_;
    }
 
public:
    int *data_;
    int size_;
};
```



#### 24、数据大小

| 数据类型       | 32位 | 64位 | 取值范围(32位)     |
| -------------- | ---- | ---- | ------------------ |
| char           | 1    | 1    | -128~127           |
| unsigned char  | 1    | 1    | 0~255              |
| short          | 2    | 2    | -32768~32767       |
| unsigned short | 2    | 2    | 0~65535            |
| int            | 4    | 4    | -2^32/2~(2^32/2-1) |
| unsigned int   | 4    | 4    | 0~2^32             |
| long           | 4    | 8    | -2^32/2~(2^32/2-1) |
| unsigned long  | 4    | 8    | 0~2^32             |
| long long      | 8    | 8    | -2^64/2~(2^64+1)   |
| 指针           | 4    | 8    |                    |
| float          | 4    | 4    |                    |
| double         | 8    | 8    |                    |
| bool           | 1    | 1    |                    |

32位与64位只在long与unsigned long上存在着细微的区别。在32位上都是4个字节，在64位上都是8个字节。

#### 25、constexpr关键字

const用于定义运行时常量，constexpr用于定义编译时常量。使用constexpr在编译时就确定了值，因此在程序运行时不会改变。

```cpp
const和constexpr都是用来定义常量的关键字，但是它们有一些区别。
const用于定义运行时常量，即在程序运行时值不会改变的变量。例如：
const int a = 10;
a的值在程序运行时不会改变。
constexpr用于定义编译时常量，即在编译时就已经确定了值的变量。例如：
constexpr int b = 20;
b的值在编译时就已经确定了，因此可以在编译时进行优化。
另外，constexpr还可以用于定义函数，表示该函数可以在编译时进行求值。例如：
constexpr int square(int x) { return x * x; }
这样定义的函数可以在编译时进行求值，而不需要在程序运行时进行计算。
```

#### 26、不能被声明为虚函数的

**①静态成员函数**

类的静态成员函数是该类共用的，与该类的对象无关，静态成员函数没有this指针，所以不能为虚函数

**②构造函数**

**③内联函数**

内联函数在编译时被展开，不会引发运行时的动态绑定。虚函数的特点就是运行时根据对象的类型调用适当的函数，而内联函数在编译时进行静态绑定，所以不适合做为虚函数。

**④友元函数**



#### 27、C++中枚举(enum)

枚举类型是C++中一种派生数据类型，它是由用户定义的若干枚举常量的集合。

**为什么使用枚举？**

开发中经常会遇到错误码，我们可以定义成常数。

```cpp
// 定义的一系列错误码如图所示：
const int ERR_SUCCESS = 0;
const int ERR_DEVICE_NOT_FOUND = 1;
const int ERR_NETWORK_FAIL = 2;
const int ERR_FILE_ALREADY_EXISTS = 3;
const int ERR_PERMISSON_DENY = 4;
const int ERROR_VERION_ERROR = 5;
const int ERR_INVAILD_DATA = 6;
const int ERR_UNKONWN = 100;

// 一个函数用于处理错误码
void HandleError(int errorCode);

/*通过上述方法会存在较多问题，无法限制errorCode的取值范围，int类型的值全都是合法的*/
```

为了解决上述问题，引入了枚举类型：

```cpp
enum ErrorCode {
    ERR_SUCCESS = 0,
    ERR_DEVICE_NOT_FOUND = 1,
    ERR_NETWORK_FAIL = 2,
    ERR_FILE_ALREADY_EXISTS = 3,
    ERR_PERMISSON_DENY = 4,
    ERROR_VERION_ERROR = 5,
    ERR_INVAILD_DATA = 6,
    ERR_UNKONWN = 100
};

// 相应的函数为：
void HandleError(ErrorCode errorCode);
// 这就限制了取值范围，如果传入的参数不是ErrorCode枚举值，即使该参数等价于枚举量的值，编译器也会报错。

// 使用方法如下：
//方法①
ErrorCode error = ERR_SUCCESS;
HandleError(error);
//方法②
ErrorCode error = ErrorCode(1);//类似于类的方法

HandleError(0);//直接输入0会报错的，因为整形变量是无法自动转换为枚举类型的变量的
HandleError(static_cast<ErrorCode>(0));//通过强制类型转换是可以正常运行的。
```

枚举的格式：

```cpp
enum [类型名] 
{
    enumerator1[=value1], //注意这里是以逗号的形式进行分割。
    enumerator2[=value2],
     ...
};
// 
```

赋值步骤：

只能把枚举元素赋值给枚举变量，不能把元素的序号值直接赋值给枚举变量。

```cpp
ErrorCode code;
code = Error_SUCCESS; // 正确
code = 0;             // 错误
```

### 二、八股文背诵

#### 1、指针和引用的区别

- 指针是一个实体（拥有自己的空间），引用只是一个别名

- 指针的大小为4个字节(使用sizeof()获得)，引用的大小指向被引用对象的大小

- 指针可以被初始化NULL，而引用必须被初始化且必须是一个已有对象的引用。指针可以被重新赋值，而引用不能进行重新赋值。

- 作为参数时也不同，传递指针的实质是传值，引用传递的实质是传递地址。指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象。

- **如果某个函数返回动态分配的内存或者对象，必须使用指针，引用可能引起内存泄漏。**

  （我们在某一个函数中，在堆区开辟了空间，那么我们必须在这个函数里返回指针，在外部可以将这个内存释放掉，否则在内部，该部分的内存是释放不掉的）

引用的本质是一个指针常量，然后指针的指向不能够改变

例如：下面

```cpp
// 使用引用
int& createIntRef() {
    int* ptr = new int(10);// 这里在堆区申请的内存无法进行释放。
    return *ptr;
}

int main() {
    int& ref = createIntRef();
    // do something with ref
    // ...
    // the memory allocated in createIntRef() is leaked
    return 0;
}

//使用指针
int* createIntPtr() {
    int* ptr = new int(10);
    return ptr;    //使用引用的话就可以直接返回引用，就可以进行释放。
}

int main() {
    int* ptr = createIntPtr();
    // do something with ptr
    // ...
    // release the allocated memory
    delete ptr;
    return 0;
}
```

####  2、堆和栈的区别

#### 3、C++中类对象的大小由什么决定

类的大小与普通数据成员有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。主要由以下几个因素来决定。

空类的大小为1。因为不能使得相同的数据成员指向一个类。**C++标准规定，凡是一个独立的(非附属)对象都必须具有非零大小**

1. 类的成员变量：类的成员变量是对象占用内存的主要因素。每个成员变量都需要一定的内存空间来存储其值。成员变量的类型和数量会直接影响对象的大小。
2. 对齐要求：许多系统对数据的存储有对齐要求，即某些类型的数据需要按照特定的边界对齐存储，以提高内存访问效率。例如，一个int类型的变量可能需要4字节对齐，而一个double类型的变量可能需要8字节对齐。对齐要求可能会导致对象的大小增加，因为编译器会在成员之间插入填充字节以满足对齐要求。
3. 继承关系：如果一个类是派生类（子类）并继承自其他类（基类），那么派生类的对象大小也会受到基类成员变量的影响。派生类对象的大小包括基类的成员变量以及派生类自身的成员变量。
4. 虚函数和虚指针：如果类中包含虚函数或者虚基类，那么编译器会为对象添加一个指向虚函数表（vtable）或虚基类表（vtable）的指针。这个额外的指针会增加对象的大小。

C++中类的大小：

```cpp
class A{}; sizeof(A) = 1; //空类在实例化时得到⼀个独⼀⽆⼆的地址，所以为 1.
class A{virtual Fun(){} }; sizeof(A) = 4(32bit)/8(64bit) //当 C++ 类中有虚函数的时候，会有⼀
个指向虚函数表的指针（vptr）
class A{static int a; }; sizeof(A) = 1;//静态成员变量并不属于这个类的对象
class A{int a; }; sizeof(A) = 4;
class A{static int a; int b; }; sizeof(A) = 4;
```



#### 4、介绍一下static关键字

`在函数内部定义的变量，保存在栈上，函数执行完成之后，变量就会释放掉，如果想要保留这个变量的话，一般采用全局变量的形式，但是定义了全局变量，就导致这个变量还受到其他函数的作用，所以利用static这个关键字来解决这个问题，通过static，既控制了存储方式，又控制了可见性`。

静态变量其实就是相当于这个变量被所有的共有，所有的变量共有这个变量。但是这个变量的作用域会有不同。

**如果`static`变量定义时未赋初值，编译时会自动将其赋值为0**

static关键字主要是控制变量的==存储方式==和==可见性（作用域）==和==生命周期==。

分为面向过程的static关键字和面向对象的static关键字

**面向过程的static关键字**

①修饰全局变量

函数外部定义的变量称为全局变量，作用域默认是整个程序，包括 .c 和 .h 文件

- 变量的存储区域在全局数据区的静态常量区(由全局区变成静态常量区)
- 变量的作用域由整个程序变为当前文件(extern)  整个程序文件变为当前程序文件
- 变量的生命周期不变

`一个全局变量被 `static` 修饰，使全局变量只能在定义变量的当前文件使用，不能在其余文件使用，即使 `extern`外部声明也不行`

**未经初始化的全局静态变量会被自动初始化为0**。降低其作用域

②修饰局部变量

定义在函数内部的变量称为局部变量，作用域仅限与函数内部，离开该函数后就是无效的。当statci修饰局部变量时：

- 变量的存储区域由**栈**变成了全局数据区静态常量区
- 变量的生命周期由局部变成去全局
- 变量的作用域不变（作用域依然是局部作用域，局部静态变量离开作用域时，该变量并没有被销毁，而是仍然驻留在内存当中，只不过我们不能对其进行访问，除非该函数再次被调用，并且该局部静态变量值不变。）

未经初始化的局部静态变量会被自动初始化为0（自动对象的值是任意的，除非它被显示初始化）

③修饰函数

- 函数的作用域由整个程序变为当前文件。

一个函数被static修饰，使得函数只能在定义的源文件使用，不能在其余文件使用，即使external外部声明也不行。

**函数的定义和声明在默认情况下都是extern的，但静态函数只在声明它的文件当中可见，不能被其他文件所用。**

```cpp
class test{
public:
    static const int sa=99;
};

```

**面向对象的static关键字**

①修饰成员变量

静态成员变量。静态成员变量一定要在类外进行初始化，类内只是进行声明。const修饰的成员除外。静态成员变量也是有访问权限的，私有的静态直接从外部是访问不了了的。必须要通过类中定义的函数来访问。

```cpp
class A{
public:
	int getcount()
    {
        return this->count;
    }
 private:
static int count;//私有的静态变量，访问不了
};
int A::count=10; //前面的int要记上

cout << A::GetCount() << endl;//只能通过这种方式来访问。
```

②修饰成员函数

静态成员函数只能访问静态成员变量。静态成员函数不能调用非静态成员函数，非静态成员函数可以调用静态成员函数。**静态成员函数**没有隐藏的this指针。



**静态变量的初始化(不包括成员函数)**

1、在C++中，==全局变量==，==全局static变量==和class的==static成员变量==在main函数之前初始化，main函数之后销毁。

2、函数(定义的某一个函数)内部的局部static变量在该函数第一次调用时初始化，main函数之后销毁。



*  所有对象共享同一份数据
*  在编译阶段分配内存
*  类内声明，类外初始化  (静态成员函数并不需要在类外进行初始化)   int Person::m_A=10;



#### 5、介绍一些const关键字

const可以用在类型说明符号前，也可以用在类型说明符号之后。被const修饰的即表示是常量性的、只读的，不可以随意修改的。因为**const对象一旦创建后其值就不能再改变，所以const对象必须要初始化**。

①const修饰普通变量

修饰普通变量就是定义了一个常 量。以下两种定义在本质上是一样的。

```cpp
int const a = 10;
const int a = 10;
//实际上，虽然不能直接对常量进行修改，但是我们可以通过指针对常量进行修改。
例如：
const int n=10;
int* p=&n;
*p=20;//通过指针进行更改
```

为什么要用const呢？如果我们没有定义常量，我们需要将100改为200，需要将代码出现的所有100依次修改为200，而如果我们定义了常量，修改一个const变量就可以了。

如果将const改为外部连接,作用于扩大至全局,编译时会分配内存,并且可以不进行初始化,仅仅作为声明,编译器认为在程序其他地方进行了定义。

②const修饰指针。

常量指针。const int * p  限制的是常量，指针指向的值不可以改变

指针常量。int * const p  限制的是指针，指针的指向不可以发生改变

常量指针常量。

③const修改数组

数组变量实际上就是const指针，所以不能直接赋值。

const修饰数组表明数组的每一个元素都是const int ，无法修改，所以必须通过初始化进行赋值。出来之后就无法进行赋值了。

④const修饰函数形参。

1.const修饰普通形参变量

`void function(const int Var);`

这里形参不会发生改变，但是实际上是没有意义的，这里的形参实际上是实参的拷贝

2.const修饰指针形参

`void function(const char* var)`   是为了限制指向的值不能够进行更改

我们把外部实参的地址赋值给用const修饰的指针形参，这样我们就无法通过指针修改其所指的外部实参，保护了数据的安全性。

`void function(char* const var)`

这样就没有意义。因为这是指针常量，表示指针的指向不可以改变，但是指针指向的值是可以改变的。

3.修饰引用形参

`void function(const type& var)`

参数为引用，将外部实参传递给引用形参，传递的是外部实参本身，无需进行拷贝，增加了效率，同时参数const是引用，无法通过引用修改实参，保证了外部数据的安全性。

**如果函数参数是非const的引用指针，他就不能接受const变量(地址)。而如果函数参数是const的引用指针，他既可以接受const变量(地址)，也可以接受非const变量地址。这是权限的缩小。**（原本只能接受左值，加入之后既可以接受左值也可以接受右值。原本右值是无法接受地址的，所以不能进行接受）

⑤const修饰函数返回值

直接用在函数前面可以修饰函数返回值

1.修饰普通类型返回值

```cpp
const int func1();
```

毫无意义，因为返回的是临时变量，临时变量本身就具有常量性。

2.修饰指针类型返回值（才有意义）

2.1 const 修饰*p

如果给以“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const修饰的同类型指针

```cpp
const int * fun2();
const int *p = fun2();//调用正常
// int* p2 = fun2();//调用失败
```

2.2 const修饰p

```cpp
int* const fun3();
int * const p = fun3();//调用正常
int *p2 = fun3();//调用正常
p2的指向依然可以改变
```

⑥关于面向对象的



1.修饰成员变量

修饰类的成员变量，表示**成员常量**，不能够被修改，**只能在初始化列表中进行赋值**

2.修饰成员函数

放在类成员函数的后面，表示不能够修改

3.修饰类对象

常函数：

- 成员函数后加上const后我们称这个函数为常函数
- 常函数内不可以修改成员属性
- 成员属性声明时加上关键字mutable之后，**常函数之内依然可以修改**

常对象：

- 声明对象前加const称为该对象为常对象
- 常对象只能调用常函数  (表明这个类中所有的成员属性都是不可以更改的)，不能调用类内其他的函数
- 常对象也不能修改成员属性的值(但是可以访问成员属性的值)，如果成员属性加上mutable,这个则是可以修改的。

#### 6、智能指针

智能指针的作用是管理指针，避免该指针忘记释放内存，造成内存泄露情况的发生。常用的有4种内存，分别是`auto_ptr`, `unique_ptr`,`shared_ptr`与`weak_ptr`

```cpp
//常用的一些接口
T* get();//获取内部封装的原生指针，cpp中普通的指针
T& operator*();//重载指针解引用
T& operator->();//重载->
T& operator=(const T& val);//重载等于运算符
T* release();//将auto_ptr封装在内部的指针置为nullptr,但是并不会破坏指针指向的内容，函数返回的是内部指针置空之前的值;
void reset(T* ptr=nullptr);//释放封装的内部指针所指向的内存，如果指定了ptr的值，就将其内部指针初始化为该值(否则就将其设置为nullptr)
```

智能指针的大小：

在32位的机器上：

std_unique_ptr 占 4 字节，std::shared_ptr 和 std::weak_ptr 占 8 字节

在64位的机器上：

std_unique_ptr 占 8 字节，std::shared_ptr 和 std::weak_ptr 占 16 字节

总体来说，std_unique_ptr 的大小总是和原始指针大小一样，std::shared_ptr 和 std::weak_ptr 大小是原始指针的 2 倍。

==1、auto_ptr==

已经弃用了，采用所有权模式。

```cpp
auto_ptr<int> p1(new int(10));
auto_ptr<int> p2;
p2 = p1;//这一行并不会报错,可以
cout << *p2 << endl;// 可以发现依然可以进行拷贝与赋值运算
cout << *p1 << endl;//不会报错，但是运行时会报错
//p2剥夺了p1的所有权，程序访问p1的时候会报错。存在潜在的内存崩溃问题。
```

==2、unique_ptr==

unique_ptr实现独占拥有或者严格拥有的概念，保证同一时间内只有一个智能指针可以指向该对象，避免资源泄露。

unique_ptr实际上是用来代替auto_ptr的，为了达到不能进行复制的目的，unique_ptr将其类的**拷贝构造函数**和**赋值运算符**重载标记为delete。

注意到这个智能指针只是不能调用拷贝构造函数和赋值运算符，但是还存在移动构造函数，所以可以通过右值引用的方式，将该指针的所有权进行转移。转移之后原先的指针就不再包含相关信息了。

```cpp
0.构造方式
std::unique_ptr<int> sp1(new int(123));

std::unique_ptr<int> sp2;
sp2.reset(new int(123));

std::unique_ptr<int> sp3 = std::make_unique<int>(123); 

1.禁止复制
unique_ptr<int> p1(new int(10));
//下面两行在IDE中直接就会报错。
//unique_ptr<int> p2(p1);拷贝构造
//p2 = p1;赋值运算

2.禁止复制也存在特例，作为函数返回值的时候可以复制(作为函数返回值的话必须需要进行测试工作)
std::unique_ptr<int> func(int val)
{
	std::unique_ptr<int> up(new int(val));
	return up;  // 作为函数返回值返回该智能指针
}
int main()
{
	std::unique_ptr<int> sp1 = func(123);
	system("pause");
	return 0;
}

3.不能赋值，但是可以将其持有的堆区内存进行转移。
std::unique_ptr<int> sp1(std::make_unique<int>(123));// std::make_unique<int>(123)构造的其实是一个右值
std::unique_ptr<int> sp2(std::move(sp1));//通过移动构造进行转移（将左值转换成右值），将sp1转移到sp2中
std::unique_ptr<int> sp3;
sp3 = std::move(sp2);//将sp2转移到sp3中
/*
以上代码利用 std::move 将 sp1 持有的堆内存（值为 123）转移给 sp2，再把 sp2 转移给 sp3。最后，sp1 和 sp2 不再持有堆内存的引用，变成一个空的智能指针对象。
*/
说明类内部存在移动构造函数，通过右值引用，
```

==3、shared_ptr==

实现共享式拥有的概念，多个智能指针可以指向相同对象，该对象和其相关资源会在"最后一个引用被销毁"时释放。

可以被多个指针共享，使用计数机制来表明资源被几个指针共享。

每当有一个shared_ptr析构时(离开某一个作用域)，其引用次数会自动减1，当其计数为0时，资源就会被释放。

当我们调用release()时，当前指针会释放资源所有权，计数减一。

相互引用会造成死锁问题，导致不能销毁。

```cpp
1.构造方法(一般通过普通指针的构造方式进行构造)
std::shared_ptr<int> sp1(new int(123));//方式1
std::shared_ptr<int> sp2;//方式2
sp2.reset(new int(123));
std::shared_ptr<int> sp3;//方式3
sp3 = std::make_shared<int>(123);


shared_ptr<int> p1(new int(10));
shared_ptr<int> p2(p1);
cout<<p1.use_count() << endl;//输出引用数量。


// 如何造成死锁问题
struct ListNode
{
    int _data;
    shared_ptr<ListNode> _next;
 
    ~ListNode() { cout << "~ListNode()" << endl; }
}
shared_ptr<ListNode> n1(new ListNode);
shared_ptr<ListNode> n2(new ListNode);
n1.get()->_next = n2;			// 代表深蓝色的线所做的事（n1结点的下一个指向n2）
n2.get()->_next = n1;			// 代表浅蓝色的线所做的事（n2结点的下一个指向n1）
```

==4、weak_ptr==

weak_ptr是一种不控制生命周期的智能指针，它指向一个 shared_ptr管理的对象。进行该对象内存管理的是那个强引用的shared_ptr的智能指针。（存在lock函数可以获得其内部指向的shared_ptr指针。）

weak_ptr可以通过shared_ptr和weak_ptr进行构造，它的构造和析构并不会引起计数的增加或者是减少.

weak_ptr 是⽤来解决 shared_ptr 相互引⽤时的死锁问题.（即两个std::shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为 0， 资源永远不会释放）

/可以通过lock函数获得所指的shared_ptr

```cpp
//可以看出weak_ptr不能直接定义智能指针对象，必须依靠shared_ptr或者已经存在的weak_ptr来创建新指针
//weak_ptr<int> p1(new int(10));直接报错
std::shared_ptr<int> sp1(new int(123));
std::weak_ptr<int> sp2(sp1);
std::weak_ptr<int> sp3 = sp1;
std::weak_ptr<int> sp4 = sp2;


// 可以通过lock函数获得所指的shared_ptr
//2.std::weak_ptr的lock()成员
std::shared_ptr<int> sp(new int(10));
std::weak_ptr<int> swp = sp;
auto a = swp.lock();// 用于取出该指针指向的共享指针
cout << *a << endl;  //10
cout << typeid(a).name() << endl;//class std::shared_ptr<int>

   /*
     *.lock()方法的功能是：判断weak_ptr所指向的shared_ptr对象是否存在。
     *若存在，则这个lock方法会返回一个指向该对象的shared_ptr指针；
     *若它所指向的这个shared_ptr对象不存在，则lock()函数会返回一个空的shared_ptr。
     
     
其还具有reset方法，是将该弱引用置为空
```

5、手写shared_ptr

```cpp
// 下面需要手写智能指针
template<typename T>
class my_shared_ptr
{
public:
	// 默认构造函数(不输入任何东西，所以默认地址和数量应该全部为0)
	my_shared_ptr() : _ptr(new T), _useCount(new size_t(0)) {}

	// 有参构造函数(输入普通指针)
	explicit my_shared_ptr(T* p) : _ptr(p), _useCount(new size_t) {
		if (p) {// 如果传入的不是空指针的话
			*_useCount = 1;
		}
		else {
			*_useCount = 0;
		}
	}
	// 拷贝构造函数
	my_shared_ptr(const my_shared_ptr& s_ptr)
	{
		_ptr = s_ptr._ptr;
		_useCount = s_ptr._useCount;// 引用计数加1
		(*_useCount)++;
	}

	//重载赋值运算符
	// 分为两步，首先，1.原本指向的内存计数需要减去1，因为自己即将被覆盖住 2.新指向的内存计数加1
	my_shared_ptr& operator= (const my_shared_ptr& s_ptr) {
		if (this != &s_ptr)// 防止进行自赋值，这里的&是取地址符
		{
			if (_ptr)// 如果本身不为空指针的话
			{
				--(*_useCount);// 原本指向的内存首先减去1
				if (*_useCount == 0)// 如果恰好该指针为最后一个指向原来地址的指针
				{
					delete _useCount;
					delete _ptr;
				}
				// 通过下面两步进行覆盖操作
				_useCount = s_ptr._useCount;
				_ptr = s_ptr._ptr;
				++(*_useCount);
			}
		}
		return *this;
	}

	int use_count() {
		return *_useCount;
	}

	// 析构函数
	~my_shared_ptr() {
		if (!_ptr || *_useCount == 1) {// 如果当前指针为空指针的话或者计数为1(说明计数不需要减1)
			delete _useCount;
			delete _ptr;
		}
		else
		{
			--(*_useCount);
		}
	}

private:
	size_t* _useCount;// 
	T* _ptr;
};
```

#### 7、函数指针

**概念：**函数指针就是指向函数的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。

**定义形式：**

```cpp
int func(int a);//某一个函数的声明
int (*f)(int a);//表明f是一个函数指针，该指针指向的函数接受的参数类型是一个int类型的,返回值类型也是int类型的。这个函数指针的类型就是通过这个参数列表进行定义的。表明该函数指针只能接受这种返回值类型和参数列表的函数。
f = &func;//将该函数指针的指向定义为func,直接用函数名也可以，函数名就是函数指针的地址。

调用方式:
//方式1
(*f)(5);
//方式2
f(5);
```

**用途：** **回调（callback）**我们调用别人提供的API函数，称为call；别人的库里面调用我们的函数，叫做callback。

函数指针简单用法如下：

```cpp
int get_sum(int a, int b)
{
	return a+b;
}
 
int get_mul(int a, int b)
{
	return a*b;
}
void show_result(int a, int b, int (*ptr)(int, int))
{
	cout<< ptr(a, b)<< endl;
	cout<< (*ptr)(a, b)<< endl;
}

int main()
{
	show_result(4, 5, get_sum);
	show_result(4, 5, get_mul);
	return 0;		
}
```





#### 8、内联函数

函数是一个可以重复使用的代码。CPU在执行主调用函数代码时如果遇到被调用函数，主调用函数就会暂停，转而执行被调函数。

函数调用是有时间和空间开销的。因为程序执行之前，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码。函数体中代码执行完毕之后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置之后的代码。

如果函数语句较少，只有一两条语句，那么大部分时间都会花费在函数调用机制上，就会造成时间较多。



为了消除函数调用时空开销，C++中提供了一种高效率的方法，即在编译时将函数调用处用函数体替换。**这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数。**



```python
inline void swap(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
swap(&m, &n);
```

1.内联函数比普通函数多了inline关键字

2.内联函数避免了函数调用的开销，而普通函数存在函数调用的开销。

3.普通函数在被调用的时候，需要寻址(函数入口的地址)；内联函数不需要。

4.内联函数有一定的限制，要求代码简单，不能包含复杂的结构控制语句，普通函数则没有这个要求。



注意内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动取消不符合要求的内联。



#### 9、C++中从代码到可执行二进制文件的过程

C++从源码到可执行文件，有四个过程，分别是**预编译**、**编译**、**汇编**和**链接**

**预编译：**主要操作如下：

**不进行语法检查**

- 将所有的 #define删除，并且展开所有的宏定义
- 处理所以的条件预编译指令，比如#if、#ifdef
- 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。
- 过滤掉所有的注释
- 添加行号和文件名标识

**编译：**

**进行语法检查**

- 词法分析
- 语法分析
- 语义分析
- 代码优化
- 目标代码生成：生成汇编代码
- 目标代码优化

**汇编：**

将汇编代码转化成机器可以执行的指令

**链接**：

将不同的源文件产生的目标文件进行链接，从而形成一个可执行的程序。

链接分为**静态链接**和**动态链接**

静态链接：

在链接的时候就已经把要调用的函数或者过程链接到生成的可执行文件中，就算把静态库删除也不会影响可执行程序的执行；生成的静态链接库，windows下以.lib为后缀，linux下以.a为后缀。

动态链接：

在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以删除动态库的时候，可执行程序就不能运行。生成的动态库链接在windows下以.dll为后缀，linux下面以.so为后缀。





==静态链接和动态链接有什么区别？==
**静态链接**
静态链接是在编译链接时直接将需要的执行代码拷贝到调⽤用处；
优点: 在于程序在发布时不需要依赖库，可以独立执行，
缺点: 在于程序的体积会相对较大，而且如果静态库更更新之后，所有可执行文件需要重新链接；
**动态链接**
动态链接是在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运⾏行行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行行到指定代码时，在共享执行内存中寻找已经加载的动态库可执⾏代码，实现运行时链接；
优点 在于多个程序可以共享同一个动态库，节省资源；
缺点 在于由于运行时加载，可能影响程序的前期执行性能

#### 10、C++中的宏定义

 #define命令是C语言中的一个宏定义命令，它用来将一个标识符定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本。

```cpp
分为不带参数的宏定义和带有参数的宏定义
注意：
1.宏定义末尾不加;
2.可以使用#undef命令终止宏定义的作用域

// 1、不带参数的宏名
# define PI 3.1415926
    
// 2、带有参数的宏名(相当于函数，但是比使用函数好，免去了函数调用的开销，提高了运行效率)
# define <宏名>(<参数表>) (<宏体>)
# define Max(a,b) ((a)>(b)? (a):(b))
```

宏定义和conost都可以定义常量，区别如下：

1.const生效于编译的阶段；define生效于预编译阶段

2.const定义的常量，是存储在内存中，需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中

3.const定义的常量是带类型的；define定义的常量是不带类型的。因此define定义的常量不利于类型检查。



#### 11、内联函数和宏函数的区别

1、宏定义不是函数，只是使用起来像函数。而内联函数本质上是一个函数，内联函数一般用于函数体代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且**内联函数不能调用自己本身**。(也即是无法实现递归)

2、**宏函数**是在==预编译==的时候把所有的宏名用宏体来替换，简单的说就是字符串替换；**内联函数**则是在==编译==的时候进行代码插入，编译器会在每处调用内联函数的地方把内联函数内容展开，节省函数调用的开销，提高效率。

3、宏定义是没有类型检查的，无论对错都是直接进行替换；而内联函数在编译的时候会进行安全检查。

#### 12、宏定义和typedef的区别

typedef主要是为数据类型定义一个新的名字。包括自定义的数据类型。define也可以为类型定义别名。

定义如下：

```cpp
#define INT_VECTOR std::vector<int>
typedef std::vector<int> IntVector;
```

define是别名->真名

typedef是真名别名

不同之处在于：

1、宏定义#define在预编译期将宏展开，并替换宏定义中的代码。只进行简单地文本替换，不涉及类型检查。typedef是在**编译阶段**处理的，有更加严格的类型检查。

2、宏定义没有作用域限制，只要在宏定义之后的地方，就可以使用宏。typedef遵循C++的作用域规则，收到命名空间、类等结构的作用域限制。





#### 12、define和const区别

- ==编译阶段：==define是在**编译预处理阶段**进行替换，const是在编译阶段确定其值
- ==安全性：==define定义的宏常量没有数据类型，只是进行简单地替换，不会进行类型安全的检查，const定义的常量是有类型的，是要进行判断的，可以避免一些低级错误
- ==内存：==define定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中存在多个备份，占用的是代码段的空间。const定义的常量占用静态存储区，程序运行过程中只有一份。





#### 12、宏函数

```cpp
#include <iostream>
#define MAX(X, Y) ((X)>(Y)?(X):(Y))
#define MIN(X, Y) ((X)<(Y)?(X):(Y))
using namespace std;

int main ()
{
    int var1 = 10, var2 = 100;
    cout << MAX(var1, var2) << endl;
    cout << MIN(var1, var2) << endl;
    return 0;
}
/*
程序运行结果：
100
10
*/
```

#### 13、C++中的extern关键字

**加入extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。**

首先明确一点，extern是关于声明的关键字。extern修饰的关键字是没有建立存储空间的关键字。

1.修饰变量：通过在一个源文件中使用`extern`关键字来声明一个在其他源文件中定义的全局变量。

extern可以用在任意的位置。

```cpp
//1、在使用cpp的文件中如下定义
// 外部变量的声明
extern int globalVariable;
int main() {
    // 使用外部变量
    globalVariable = 10;
    return 0;
}

//2、在另一个源文件中，定义该全局变量
int globalVariable;
```

2.修饰函数

和修饰变量一样。通过在一个源文件中使用extern关键字声明一个在其他源文件中定义的函数。这样做可以使得多个源文件共享同一份函数定义，而不需要重新定义它。(多个源文件共享同一份函数定义)

外部函数的声明可以放在函数内部、文件的最外层或者头文件中。

**extern的引用方式比包含头文件要简洁得多！**extern的使用方法是直接了当的，**想引用哪个函数就用extern声明哪个函数**。

使用external声明就不需要加入头文件了。

```cpp
// 外部函数的声明
extern void externalFunction();

int main() {
    // 调用外部函数
    externalFunction();
    return 0;
}

//在另一个源文件中
// 外部函数的定义
void externalFunction() {
    // 函数实现
}
```

3.在C++中调用c函数

c语言不支持函数重载，**编译c语言的时候并不会带上函数的参数类型**。因此如果想用C++来调用c语言写的函数的话，用到extern关键字。

编译C语言的时候不会带上函数的参数类型。

```cpp
// C 语言代码
#include <stdio.h>

void print_message(const char* message) {
    printf("%s\n", message);
}
```

```cpp
// C++ 代码
extern "C" {
    // 声明 C 语言函数
    void print_message(const char* message);
}

int main() {
    // 调用 C 语言函数
    print_message("Hello, world!");
    return 0;
}
```

#### 14、explicit关键字

 限制隐式类型转换，提升代码的可读性。**一般用于构造函数的声明中**，防止隐式类型转换。如果构造函数中使用了explicit关键字，则只能使用显示转换进行转换，而不能进行隐式转换。

- 只能用来修饰类构造函数
- explicit修饰的构造函数不能被隐式调用
- 禁止类对象之间的的隐式转换

```cpp
//类中的构造函数如果只含有一个参数，默认情况下存在一种隐式转换，即定义了转换为此类类型的隐式转换机制。然而，这种机制并非总是合理//的，甚至容易产生错误，因此，新标准增加了explicit关键字，用来限制隐式转换
class Test {
public:
    Test();  // 空构造函数
    Test(double a); // 含一个参数的构造函数
    Test(int a, int b); // 含两个参数的构造函数
    Test(int a, double b = 1.2);  // 带有默认初始值的构造函数
    ~Test();
};

// 调用
Test d1(12.3);  //直接使用默认构造函数
Test d2 = 1.2;  // 也是调用含有一个参数的构造函数，但是包含一次隐式转换
Test d3(12, 13);  
Test d3 = 12;  // 隐式转换，调用带有默认初始值的构造函数Test(int a, double b = 1.2)
上述方法是隐式调用其构造函数

//explicit用在类的构造函数前面
class Test {
public:
    Test() {}  // 空构造函数
    explicit Test(double a); // 该构造函数无法进行隐式类类型转换
    explicit Test(int a, int b);  // 含有两个参数，explicit对其无效，然而该构造函数本身也是不能隐式转换的
    explicit Test(int a, double b = 1.2);  // 该构造函数无法进行隐式类类型转换
    ~Test() {}
};

// 调用
Test d1(12.3);  // 正确
Test d2 = 1.2;  // 错误，不能进行隐式类类型转换
Test d3(12, 13);  // 正确
Test d3 = 12;  // 错误，不能进行隐式类类型转换

//explicit就是用来限制隐式类型转换的，用来提升代码的可读性
```

另外一种用法：

```cpp
class A
{
public:
    explicit A(int a, int b) : m_a(a), m_b(b) {};
private:
    int m_a;
    int m_b;
};

int main()
{
    A test(1, 2); //正确
    A test1(2.2, 2); // 错误，存在double->int的隐式转换。
}
```



#### 15、C++中的几种类型转换

在C语言中，大多采用`(type_name) expression `这种方式来做强制类型转换，更推荐使用如下四个转换操作符来实现显示类型转换。

- static_cast

用于同族类型转换，无法让两个不相关的类型进行转换（编译器隐式执行的任何类型转换都可以使用static_cast进行转换）。

没有运行时类型检查来保证转换的安全性。

进行上行转换（派生类的指针或者引用转换成基类表示）是安全的。

进行下行转换（基类的指针或者引用转换成派生来表示) 由于没有动态类型检查，所以是不安全的。



- dynamic_cast

用于将父类对象的指针或者引用转换成子类对象的指针或者引用

进行下行转换时，dynamic_cast具有类型检查，比static_cast更加安全

转换后必须是类的指针、引用、void*，基类需要具备虚函数

本身只能用于存在虚函数的父子关系的强制类型转换；对于指针，转换失败则返回nullptr，对于引用，转换失败则会抛出异常。

- const_cast

常量指针转换为非常量指针，并且依然指向原来的对象。常量引用被转换为非常量引用，并且依然指向原来的对象。

去掉类型的const或volatile

- reinterpret_cast



1.static_cast

用法：`static_cast <new_type>(expression) `

最常用，可以用于各种隐式转换，比如非const转const

和c语言()作强制类型转换是等价的。主要用于以下场景。

- 1.1基本类型之间的转换

将一个基本类型转换成另一个基本类型。

```cpp
int a = 42;
double b = static_cast<double>(a); //将整数a转换成双精度浮点数
```

- 1.2指针类型之间的转换（基类指针转换为子类指针，存在虚函数的基类一般不能实例化对象）

将一个指针类型转换为另一个指针类型，可以从基类指针转换为派生类指针。==这种转换不执行运行时类型检查，可能不安全，要保证自己指针确实可以互相转换。==

```cpp
class Base{};
class Derived : public Base
{};									// 进行上行转换，将基类的指针或者引用转换给子类表示。
Base* base_ptr = new Derived();                        // 初始化一个基类指针
Derived* derived_ptr = static_cast<Derived*>(base_ptr);// 将其转换为派生类指针
```

- 1.3引用类型之间的转换（基类引用转换为子类引用）

类似于指针类型之间的转换，可以将一个引用类型转换为另一个引用类型。

```cpp
Derived derived_obj;
Base& base_ref = derived_obj;          // 将基类中的引用转换给子类进行表示
Derived& derived_ref = static_cast<Derived&>(base_ref); // 将基类引用base_ref转换为派生类引用derived_ref
```

`static_cast`在编译时执行类型转换，在进行指针或引用类型转换时，需要自己保证合法性（不会进行类型检查）。

2.dynamic_cast

用法：`dynamic_cast<new_type>(expression)`

`dynamic_cast`在C++中主要应用于父子类层次结构中的安全类型转换。

在运行时执行类型检查（转换失败也可以正常运行），因此相对于`static_cast`更加安全。`dynamic_cast`的主要应用场景。

- 2.1向下类型转换

当需要将基类的指针或者引用转换为派生类指针或者引用时，dynamic_cast可以确保类型兼容性。

如果转换失败，`dynamic_cast`将返回空指针(对于指针类型)或者抛出异常(对于引用类型)。

`dynamic_cast`只有在基类存在虚函数的情况下才有可能将基类指针转换为子类。

```cpp
class Base { virtual void dummy() {} };
class Derived : public Base { int a; };

Base* base_ptr = new Derived();
Derived* derived_ptr = dynamic_cast<Derived*>(base_ptr); // 将基类指针base_ptr转换为派生类指针derived_ptr，如果类型兼容，则成功
```

3.const_cast转换

主要用于const转换成非const的成员属性

用法：`const_cast <new_type> (expression)`

new_type必须是一个指针、引用或者指向对象类型成员的指针。

多用于去除const的性质。

- 3.1修改const对象

```cpp
const int a=42;
int * mutable_ptr = const_cast<int*>(&a);//删除const属性，使得可以修改a的值。
*mutable_ptr = 43;// 修改a的值
```

- const对象调用非const成员函数

当需要使用const对象调用非const成员函数时，可以使用`const_cast`删除对象的const属性。

```cpp
class MyClass {
public:
    void non_const_function() { /* ... */ }
};

const MyClass my_const_obj;// 常函数只能调用常对象
MyClass* mutable_obj_ptr = const_cast<MyClass*>(&my_const_obj); // 删除const属性，使得可以调用非const成员函数
mutable_obj_ptr->non_const_function(); // 调用非const成员函数
```

4.reinterpret_cast

从底层对数据进行重新解释，依赖具体的平台，可移植性差。

可以将整形转 换为指针，也可以把指针转换为数组；可以在指针和引⽤ 之间进⾏肆⽆忌惮的转换。





#### 16、C++中字符串

char*和其他指针的不同之处在于当你直接输出cout时，其输出的并不是地址，而是字符串，要想输出地址，其前面必须加上取址符号&

```cpp
// 1.char*表示一个字符指针，其指向字符串首字母
/*
和其他指针的不同之处在于当你直接输出cout时，其输出的并不是地址，而是字符串，要想输出地址，其前面必须加上取址符号&
*/
const char* str2 = "wangming";   // 一般情况下char*需要与const搭配使用才可以
std::cout << str2 << std::endl;  // wangming
std::cout << *str2 << std::endl; // w(可以直接被解引用，解引用值为首地址的值)

// 2.字符数组char []
char str[] = "wangming";// 等价于char str[] = "wangming";
std::cout << sizeof(str) << std::endl;// 输出为9,末尾被自动添加了\0。
std::cout << str << std::endl;// wangming 和char*一样直接输出的为字符串。

// 3.string表示字符串
// string表示C++中的一个类，该类的作用就是管理字符串
// string提供了一个方法可以将string类转换成char * const类型
std::string str = "wangming";
std::cout <<typeid(str).name() << std::endl;// class std::basic_string
std::cout << typeid(str.c_str()).name() << std::endl;// char const *
// 如果想要得到char*类型，则可以通过下述方法
char * str2= const_cast<char*>(str.c_str());//利用静态转换去掉const属性
```

#### 17、右值引用

**1、C++中右值引⽤概念？**

​		C++中，右值引用是一种特殊的引用类型，用于标识临时对象（右值）的引用。右值引用允许我们将临时对象的资源“窃取”或者转移给另一个对象，不进行深拷贝。右值引用的语法是利用两个&&来进行标识。

**2、为何要引⼊右值引⽤？**

​		引用右值的主要目的是实现移动语义，右值引用允许我们在拷贝对象时直接窃取其资源，并将其置空，而不进行赋值，通过使用移动构造函数和移动赋值运算符，可以将资源从临时对象转移到新的对象中，避免了不必要的深拷贝，提高了程序的性能和效率。

​		右值引用的引入还为实现完美转发提供了支持，使得泛型编程和模板函数更加灵活和高效。



在使用右值引用时，通常需要搭配移动构造函数和移动赋值运算符来完成资源的转移操作。这种组合可以避免不必要的深拷贝，提高程序的性能和效率。

#### 18、lambda函数

lambda是一个匿名函数，提供了一个类似匿名函数的特性，lambda表达式表示一个可调用的代码单元，没有命名的内联函数。

1.lambda表达式的语法

```cpp
[capture list](parameter list)->return type {function body}
// [捕获列表](参数列表)->返回类型 {函数体}
// 只有捕获列表和函数体是必须的，其他的东西都可以省略掉，包括返回值类型也可以进行自动的推导，不需要明确的指出

int x = 10;
auto lam = [&x](int a)->int { std::cout << "hello" << std::endl; return x + 3; };
int y = lam(x);// 通过捕获列表，可以捕获得到上文中的参数，而且可以以引用的方式进行捕获。普通函数如果想要获得上文中的变量则必须要通过函数参数列表进行捕获
//lam类型就是type=class <lambda_7d540f07af7a251bf868b5ce463f89cc>
```

2.lambada表达式的特点

主要就是引用捕获和值铺货

变量的捕获才是成就lambda表达式的重要的特点。**可以通过传值或者引用的方式捕捉其封装作用域内的变量**。

[]：默认不捕获任何变量

[=]：默认以值捕获**所有变量**；所有变量的含义就是上文中的所有变量。

[&]：默认以引⽤捕获**所有变量**；

[x]：仅以值捕获x，其它变量不捕获； 

[&x]：仅以引⽤捕获x，其它变量不捕获； 

[=, &x]：默认以值捕获所有变量，但是x是例外，通过引⽤捕获； [&, x]：默认以引⽤捕获所有变量，但是x是例外，通过值捕获； [this]：通过引⽤捕获当前对象（其实是复制指针）； 

[*this]：通过传值⽅式捕获当前对象



3.STL算法中利用lambda表达式

```cpp
int val =3;
vector<int> v{1,8,5,3,6,10};
int count = std::count_if(v.begin(),v.end(),[val](int x) {return x>val;})
```

#### 19、虚函数表

为了实现C++的多态，C++中使用了一种动态绑定技术，这个技术的核心是虚函数表。

每个包含虚函数的类都包含一个虚表，**虚表是一个指针数组，其元素是虚函数的指针**。类中普通的函数为非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。

虚表是属于类的，而不是属于某一个具体的对象，一个类只需要一个虚表即可，同一个类的所有对象都使用同一个。

==注意：==如果是多继承，则有多个虚表指针。**继承几个类，就有几个虚表，就存在几个虚指针。**

![](./assert/3.png)



[]: https://blog.csdn.net/primeprime/article/details/80776625?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E2%80%98%E2%80%99&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-80776625.142^v92^chatsearchT0_1&amp;spm=1018.2226.3001.4187	"虚函数表"

<img src="./assert/1.png" style="zoom:50%;" />



```cpp
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
 
class B : public A {
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
};
 
class C: public B {
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
};

//1、每一个函数对应的虚函数表如上图所示。每一种定义的类都包含一个虚表(该类的所有对象共有这个虚表)
//2、每一个实例化的对象都包含一个指向虚函数表的指针
//3、对象的虚表指针指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数。
```

#### 20、构造函数的执行顺序

继承为出现的顺序，类型为声明的顺序。**先是继承的基类，再是函数对象，最后才是本身**。

构造函数顺序：

- 如果有多个基类，则构造函数的调⽤顺序是某类在**类派⽣表**中出现的顺序，⽽不是它们在成员初始化表中的顺序
- 成员类对象构造函数。如果有多个成员类对象则构造函数的调⽤顺序是对象在类中被声明的顺序，⽽不是它们出现在成员初始化表中的顺序
- 派⽣类构造函数

析构函数顺序：

- 调⽤派⽣类的析构函数；
- 调⽤成员类对象的析构函数；
- 调⽤基类的析构函数。



基类的构造函数、类对象成员的构造函数以及本类的构造函数

首先执行基类中的构造函数，再执行本类中的构造函数。

#### 21、C++中命名空间

```cpp
#include<iostream>
using std::cout;
using std::endl;
namespace own
{
	int a = 2;
}
using namespace own;//把own命名空间解放，把所有内容放到全局域中,就会与全局域中的a值相冲突，存在问题
int a = 3;
int main()
{
	cout << a << endl;//此处报错
	return 0;
}
```

#### 22、sizeof与strlen的区别

**Sizeof**:是C++的运算符，编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度，不**包含空字符串**
**strlen**：是头文件的函数，只能测量字符串 计算字符串 str 的长度，直到空结束字符，**但不包括空结束字符**

```cpp
// strlen不可以用于string类型的字符串，但是可以用于其他求其他两种字符串的长度，在求解str2[]时会自动去掉末尾的/0
const char* str1 = "wnawmffffff";	// 一共是11个字符
char str2[] = "wnawmffffff";// 一共是11个字符
std::cout << strlen(str1) << std::endl; // 11
std::cout << strlen(str2) << std::endl; // 11
std::cout << sizeof(str2) << std::endl; // 12(末尾存在一个'/0')
```

①sizeof计算大小的技巧

- 指针的大小永远是固定的，取决于处理器位数，32为4字节，64位就是8字节
- 数组作为函数参数时会退化为指针(在函数内部，使用 `strlen` 计算数组的大小时，数组不会退化为指针)
- struct结构体要考虑字节对齐
- 字符串数组要算上末尾的'\0'

使用sizeof的话数组会退化成指针。

```cpp
char  str[] = "Hello World";
char* p = str;
int n = 10;
void* vp = malloc(100);

std::cout << sizeof(str) << std::endl; // 11个字符 + 末尾'\0'，总结第四点
std::cout << sizeof(p) << std::endl;   // 4，
std::cout << sizeof(n) << std::endl;   // int 一般 4 个字节
std::cout << sizeof(vp) << std::endl;  // 4个字节，依然为指针

void Func(char str[])
{
	std::cout << sizeof(str) << std::endl;// 使用sizeof会退化成指针，但是使用strlen不会退化为指针。
}
Func(str);// 退化为指针，4个字节

struct AlignedStruct {
	char a;   // 本来1字节，padding 3 字节
	int b;    //  4 字节
	short c;  // 本来 short 2字节，但是整体需要按照 4 字节对齐(成员对齐边界最大的是int 4) ，
	//所以需要padding 2，总共: 4 + 4 + 4
};
std::cout << sizeof(AlignedStruct) << std::endl;// 12字节
```

#### 23、指针数组与数组指针

- 数组指针，指向数组的指针

```cpp
double (*p)[m];
// 括号的优先级比较高。表明p是一个指针，指向双精度浮点型的一维数组，此时数组的长度为m,执行m+1操作时，pp需要跨过m个双精度浮点型数据长度
```

- 指针数组，元素是指针的数组。

```cpp
double *p[m];
// p是一个数组，其内部保存的是double*类型的指针。
```

#### 24、C++中传值方式

传参方式有这三种：**值传递、引用传递、指针传递**

1. 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；
2. 引用传递：形参在函数体内值发生变化，会影响实参的值；
3. 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；

#### 25、volatile关键字

本义是易变的，volatile关键字是类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如操作系统、硬件或者其它线程等，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。

当要求使用volatile声明变量的值的时候，系统总是从它所在的内存读取数据，即使前面的指令刚刚从该处读取过数据



#### 26、new/delete与malloc/free的区别

1、new/delete是操作符，malloc/free 是库函数。

2、使用new,首先在堆区申请了内存，二调用了类的构造函数初始化这块内存**。而delete则是**一调用该类的析构函数**，**二是释放该堆区申请的内存**，而malloc和free只是分配和释放内存，仅仅是释放了这个对象所占的内存，而不会调用这个对象的析构函数。

3、new建立的是一个对象，而malloc分配的是一个内存。new出来的对象就是一个带有类型的指针，而malloc的是void指针，需要进行转换。

使用new



#### 26、C++中内存模型

在执行C++程序的过程中，内存大致分为四个区域：

1. **栈区(Stack)**：用于实现函数调用。由编译器自动分配释放，存放函数的参数值和局部变量等

2. **堆区(Heap)**：用于存放动态分配的变量。由程序员动态分配和释放，使用new和delete操作符

3. **全局/静态存储区(Data Segment & BSS Segment)**：存放全局变量和[静态变量](https://www.zhihu.com/search?q=静态变量&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"647137725"})，程序结束时释放
   数据段 Data Segment (全局/静态存储区) : 存放初始化了的全局变量和静态变量和常量。
   BSS段 BSS Segment : 用于存放未初始化的全局变量和静态变量（没有常量），节省空间，实际上不占用磁盘空间

   未经过初始化的全局变量和静态变量，编译器通常将其设置为0；

4. **代码区(Text Segment)**：通常也被称为[文本区](https://www.zhihu.com/search?q=文本区&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"647137725"})或只读区。存放程序的二进制代码和常量，代码段是只读的，可以被多个进程共享

#### 27、C++中字符串操作函数

- strcpy()函数

```cpp
char* strcpy(char* destination, const char* source);
```

```cpp
# include<cstring>

```



#### 28、如何避免内存泄露

- 使用智能指针
- 规范使用new / delete  new[]/delete[]
- 使用内存监测工具



#### 29、重写和重载的区别

==重写：重写和重载是不一样的，函数返回值类型，函数名，参数列表完全一致称为重写==

==虚函数：在类内成员函数中加入virtual关键字，就变成虚函数，那么编译器在编译的时候就不能确定函数调用了==



而重载，指相同作用域中被声明的几个具有不同参数列表(参数的类型、个数和顺序)的同名函数，根据参数列表确定调用哪一个函数。重载不关心函数返回类型，不能够依靠函数返回类型来进行判断。

#### 30、C++三大特性

1.面向对象编程(面向对象编程的三大特性是封装、继承和多态)

2.泛型编程

C++提供模板机制，允许你编写通用的代码，能过处理不同数据类型的数据，而不需要为每一种数据类型编写单独的代码。这使得C++能够实现高度可重用的数据结构和算法，比如标准模板库中的容器和算法

3.低级系统编程支持

C++是一门系统级编程语言，可以直接访问计算机的底层硬件资源，比如内存地址和指针。这使得C++适用于开发操作系统、驱动程序、嵌入式系统和其他需要对硬件进行细粒度控制的应用程序。C++还允许直接操作内存，但是这也增加了出错的风险，因此需要小心处理。



### 三、STL容器相关

#### 1、vector容器中push_back与emplace_back

push_back是先构造临时对象，再将这个对象拷贝到vector容器的末尾。

emplace_back直接在末尾就地构造，省略了拷贝的过程。

主要应用于自定义数据类型。对于自定义数据类型，直接输入构造就可。emplace_back接受的参数是构造元素所需要的参数，直接在vector容器中构造新元素，避免了额外的拷贝操作。

```cpp
//自定义类a
class A {
public:
	A(int i)
	{
		cout << "构造函数" << endl;
		str = to_string(i);
	}
	A(const A& other): str(other.str)
	{
		cout << "拷贝构造" << endl;
	}
	~A()
	{
		cout << "析构函数" << endl;
	}
public:
	string str;
};

int main()
{
	vector<A>vec;
	vec.reserve(10);
	A(0);
	for (int i = 0; i < 10; i++)
	{
		// vec.push_back(A(i));//先创建匿名对象(包含构造与析构)，再将匿名对象拷贝过来。10次构造函数与10次拷贝构造函数。
		// vec.emplace_back(i);//注意这里直接输入i，也就是构造函数参数就行。这里会调用10次拷贝构造函数。
        // 如果是两个参数的话就将两个参数给输入进去。
	}
	cout << "---------------------------" << endl;
	return 0;
}
```

#### 2、unordered_map和map区别

①实现不同

- unordered_map底层是用哈希表实现的

- map底层采用红黑树实现

②性能不同

- unordered_map是不按照键值对排序的，插入时间是O(logn)，查询时间是O(1)
- map是按照键值排序的，插入时间和查询时间都是O(logn)

③使用范围不同

- unordered_map使用比较局限，它的key只能是int、double等基本类型以及string，而不能是自定义的结构体。
- map可以支持所有类型的键值对

④有序性不同

由于map内部是基于红黑树实现的，因此是按照**键**值进行排序的。

#### 3、unordered_set和set的区别

1. `set`基于红黑树实现，红黑树具有**自动排序的功能**，因此map内部所有的数据，在任何时候，都是有序的。
2. `unordered_set`基于哈希表，数据插入和查找的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存，**无自动排序功能**。底层实现上，使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用`hash`函数对`key`进行映射到不同区域进行保存。



#### 4、vector容器清空方法

使用clear与erase，虽然只是size变成了0，但是容量依然是之前的值。

①clear

```cpp
vec.clear(); //清空元素，但是不回收空间
```

②erase

也是不回收空间

```cpp
vector<int>::iterator it;
for(it = vec.begin();it!=vec.end();)
{
    it = vec.erase(it);
}
```

清空元素但是不回收空间。

③使用swap，清除元素并且回收内存

```cpp
vec.swap(vector<int>());
```

### 四、C++11相关

1.智能指针

2.空指针nullptr

3.lambda表达式

4.右值引用

1. **自动类型推断 (auto)**：允许编译器自动推断变量的类型。
2. **范围for循环**：简化遍历容器（如数组、容器）的语法。
3. **nullptr**：引入了空指针字面量，用于明确表示空指针，替代了C++03中的`NULL`。
4. **初始化列表**：引入了初始化列表，可用于初始化数组、容器、类的成员等。
5. **Lambda表达式**：允许在代码中定义匿名函数，方便实现函数对象和回调函数。
6. **智能指针**：引入了`std::shared_ptr`、`std::unique_ptr`和`std::weak_ptr`，提供更安全和自动的动态内存管理。
7. **移动语义**：引入了右值引用（&&）和移动构造函数，允许高效地将资源（如内存）从一个对象转移到另一个对象，减少了不必要的数据复制。
8. **标准库改进**：引入了新的标准库组件，如`std::unordered_map`、`std::unordered_set`、`std::thread`等。
9. **类型别名**：引入了`using`关键字，允许为类型定义别名，提高代码可读性。
10. **用户定义字面量**：允许用户自定义字面量，以增强编程语言的表达能力。
11. **右值引用和移动构造函数**：引入了右值引用（Rvalue Reference）和移动构造函数，以支持移动语义，减少不必要的数据拷贝。
12. **多线程支持**：引入了多线程支持，包括`std::thread`和其他相关库。
13. **constexpr关键字**：允许在编译时计算表达式，以提高性能。
14. **初始化列表构造函数**：可以使用初始化列表来构造对象。
15. **委托构造函数**：允许一个构造函数调用另一个构造函数，减少代码重复。
16. **override和final关键字**：用于更明确地指定函数的重写和防止进一步重写

#### 5.final关键字和override关键字

**1）final关键字**(用在类和函数的末尾)

final关键字用于类、函数和虚函数的声明，用于阻止类的继承和虚函数的重写。

- 类的声明中，使用final关键字可以将该类声明为“不可继承的”，即其他类不能再从这个类派生子类。
- 在虚函数的声明中，使用final关键字可以阻止派生类重写该虚函数，否则会产生报错。

是一种去虚拟化的优化技巧，相当于把运行期多态转换为了编译期多态，提高了执行效率。

```cpp
struct Base1 final { };
struct Derived1 : Base1 {}; // 编译错：Base1不允许被继承

struct Base2 {
 virtual void f1() final;
 virtual void f2();
};
struct Derived2 : Base2 {
 virtual void f1();             // 编译错：f1不允许重写
 virtual void f2(int) override; // 编译错：⽗类中没有 void f2(int)
};
```

**2）override关键字**

显式地标识派生类中的函数，表明它是基类中的虚函数的重写。

- 当派生类重写基类虚函数时，使用override关键字可以提高代码的可读性和安全性。

```cpp
class Base {
public:
    virtual void foo() const;
};

class Derived : public Base {
public:
    void foo() const override; // 使用 override 表示该函数是对基类虚函数的重写
};
```





### 二、一些实际面试八股文

### 代码基础

这部分代码基础其实和其他互联网公司的代码相关问题区别不大，毕竟自动驾驶相关岗位也都是整天和代码打交道。有了扎实的代码基础才能又好又快地实现自己设计地算法。这里地代码基础主要包括c++的基础知识以及手撕代码。下面还是列一下高频问题。 c++基础：

1. c++ 多态、用途
2. static 关键字， const关键字
3. 智能指针各自的定义、用途、底层实现。
4. 多进程、多线程、互斥锁
5. 虚函数原理、用途
6. c++ 标准库中的各种数据结构的原理、区别以及常用接口区别



手撕代码部分一般最多就是中等难度，需要大家多多练习

1. 快排以及快排的各种变种（很重要，很常见，建议多练习几遍）
2. 反转链表、判断链表中是否有环、环的位置
3. 二叉树的遍历
4. 动态规划
5. 其他（大家可以关注一下牛客的上周考过专栏）



[C++ 面试指北介绍 | 编程指北 (csguide.cn)](https://csguide.cn/cpp/intro.html)



- 虚拟内存相关详细讲一下
- 讲讲左值和右值
- 什么时候使用右值
- 完美转发
- 假如 a 是 T 的左值引用，T 是 int&& 类型的，那么 a 实际上是什么
- 讲一下智能指针
- shared_ptr 和 unique_ptr 区别，以及性能对比
- weak_ptr 及其作用
- shared_ptr 是线程安全的吗
- lambda 表达式有哪些捕获类型
- 讲讲多态及实现机制
- 虚基类
- 多继承的时候，虚函数表指针怎么存
- using std::cin 和 在using namespace std 后使用cin有什么区别
- 元编程



C++静态多态和动态多态区别

C++函数指针有哪几类？[函数指针](https://www.zhihu.com/search?q=函数指针&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"424167104"})、lambda、仿函数对象分别是什么？

如何利用谓词对给定容器进行自定义排序？

传递引用和传递值的区别？传递常引用和传递引用之间的区别？传递右值引用和传递引用之间的区别？

函数对象应该通过什么传递？

什么是万能引用？用途是什么？

什么是完美转发？用途是什么？

std::unorded_map和std::map之间的差异是什么？

[虚函数](https://www.zhihu.com/search?q=虚函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"424167104"})、虚表的原理

如何在c++中创建线程？如何在线程间同步？

互斥锁是什么？用途是什么？条件变量又是什么？为什么要用条件变量？

智能指针和祼指针之间的差异？为什么要用指针的引用计数？

智能指针分哪几种？std::[unique_ptr](https://www.zhihu.com/search?q=unique_ptr&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"424167104"}), std::shared_ptr, std::[weak_ptr](https://www.zhihu.com/search?q=weak_ptr&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"424167104"})各有何用途？

悬挂指针会导致什么问题？如何避免？

[traits](https://www.zhihu.com/search?q=traits&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"424167104"})是什么？什么时候用traits？



1. C++的编译方式，局部变量储存在哪个区？

2. debug方式。如果代码运行后，运行到固定的某个地方后崩溃了，和运行不知道哪里忽然就崩溃了，而且发生崩溃的时间不同，你分别怎么处理？

3. const作用？int* const 和const int* 的区别？函数后面加一个const有什么作用？

4. C++的继承中，public private和protected三种类型继承的区别？一般用哪一个？为什么？

5. 多态的类型?分别用于什么场景？使用条件？

6. 在A中写了 include<B>,在B中写了include<A>,会出错，怎么解决？造成循环引用的问题，有两种方式来进行解决

这就需要  

7. 常用的STL容器？vector不断扩容会发生什么？使用reserve如果无法预先知道预先分配的内存要如何做出改进？

8. unordered_map和map的区别，底层实现，效率稳定性等



1. C++中有值传递和引用传递,python里面没有，那么如何知道python里面一个变量是值传递还是引用传递？

2. open()和with_open()的区别

1. 多态如何实现？底层如何实现？
2. 智能指针分类、作用及使用方法？`shared_ptr`的缺点？如何避免？
3. 右值引用？了解forward函数的具体实现吗？
4. `map`和`unordered_map`的区别及适用场景

namespace的作用，线程进程的区别

左值引用和右值引用的区别联系，右值引用的作用

C++虚函数的原理是什么

虚函数表



C++ 常使用哪些 STL 容器

map 和 [unordered_map](https://www.zhihu.com/search?q=unordered_map&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"546948468"}) 区别和底层实现是什么

map 除了查询复杂度高还有什么缺点

vector 增删改查复杂度分别是什么

vector 支持越界检查吗

讲讲 vector 扩容

push_back 的复杂度一定是 O(1) 吗，不一定，超出容量了

push_back 和 emplace_back 区别

emplace_back 可以传对象吗

移动构造函数和[拷贝构造函数](https://www.zhihu.com/search?q=拷贝构造函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"546948468"})区别

智能指针用过哪些，讲讲特点

[shared_ptr](https://www.zhihu.com/search?q=shared_ptr&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"546948468"})，引用计数何时增加和减少

如何用普通[指针初始化](https://www.zhihu.com/search?q=指针初始化&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"546948468"}) shared_ptr

用普通指针初始化 shared_ptr 这种用法有什么坏处

static 变量可以用在哪些地方，分别有什么特点

static 修饰的普通变量初始化在 main 函数执行前还是后

类的 static 方法可以访问非 static 对象吗

设计模式知道哪些



为什么把 QP 问题从凸优化问题分割出来？

1. QP不需要迭代求解，且QP问题定义的约束是线性的

怎么求解非线性优化问题？ 

1. 梯度下降

2. 牛顿法

3. 1. （高斯牛顿法）

4. [拟牛顿法](https://www.zhihu.com/search?q=拟牛顿法&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"620568795"}) 

5. 1. 线搜索

   2. 1. DFP
      2. BFGS
      3. L-BFGS

   3. 置信域

   4. 1. LM

[非线性最小二乘](https://www.zhihu.com/search?q=非线性最小二乘&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"620568795"})能不能加硬约束？ 

1. 不能，因为非线性最小二乘将约束设置为[惩罚函数](https://www.zhihu.com/search?q=惩罚函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"620568795"})

高斯牛顿法 

1. *高斯牛顿法*是对牛顿法的一种改进，它用[雅克比矩阵](https://www.zhihu.com/search?q=雅克比矩阵&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"620568795"})的乘积近似代替牛顿法中的二阶Hessian 矩阵，从而省略了求二阶Hessian 矩阵的计算
2. 参考[高斯—牛顿迭代法_百度百科](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E9%AB%98%E6%96%AF%E2%80%94%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/15667583)
3. 参考[https://scm_mos.gitlab.io/algorithm/newton-and-gauss-newton/](https://link.zhihu.com/?target=https%3A//scm_mos.gitlab.io/algorithm/newton-and-gauss-newton/)

[高斯牛顿](https://www.zhihu.com/search?q=高斯牛顿&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"620568795"})和梯度下降的更新有什么异同点？ 

1. 梯度下降: x_i+1 = x_i - alpha * J
2. 牛顿: x_i+1 = x_i - lambda * H^-1 * J
3. 高斯牛顿： 舍弃二阶项， 利用残差r和[雅可比矩阵](https://www.zhihu.com/search?q=雅可比矩阵&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"620568795"})更新 x_i+1

A* 能找到最优路径吗？  



作者：Giovannitrials
链接：https://zhuanlan.zhihu.com/p/620568795
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



蔚来

leetcode 20. 有效的括号

c++左值和右值的区别

滴滴

leetcode 150. [逆波兰表达式](https://www.zhihu.com/search?q=逆波兰表达式&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"647516099"})求值

explicit 关键字用法

构造函数，[析构函数](https://www.zhihu.com/search?q=析构函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"647516099"})能不能是虚函数

[智能指针](https://www.zhihu.com/search?q=智能指针&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"647516099"})

list和vector区别

autox

static 关键字作用

leetcode 64. 最小路径和

字节 ai lab 机器人

A*     rrt* 原理

虚函数

push_back    emplace_back区别

leetcode 48. 旋转图像

momenta

leetcode 300. [最长递增子序列](https://www.zhihu.com/search?q=最长递增子序列&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"647516099"})

osqp内部计算原理

百度

leetcode 102. 二叉树的[层序遍历](https://www.zhihu.com/search?q=层序遍历&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"647516099"})

leetcode 226. 翻转二叉树



作者：牛客校招
链接：https://zhuanlan.zhihu.com/p/647516099
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



- vector八股知识点及手动实现相关函数
  - vector底层
  - push_back实现原理
  - 原生数组有什么缺点
  - size()和capacity()区别
  - public,protected,private
  - 手撕：实现push_back函数 







PID算法：

[(笔记)PID算法讲解（原理+算法+源码） - tdyizhen1314 - 博客园 (cnblogs.com)](https://www.cnblogs.com/tdyizhen1314/p/16998628.html)

```cpp
给你一个数组，长度为N，avg为其第i个数前后K个数的平均值(包含第i个数)，ag数组的长度也为N，求最小的avg
例如:数组[1,2,3,4,5,6,7,8],假设K为2
avg[0]=(1+2+3) /3
avg[1]=(1+2+3+4)/4
avg[3]=(2+3+4+5+6)/5
avg[7]=(6+7+8)/3
实现一个该功能的函数，期望时间复杂度为O(N)
```

  
