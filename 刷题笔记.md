#   用于记录算法笔记
这是我之前的刷题笔记

### 0、用来记录一些简单的思想东西

动态规划和递归思想的区别，动态规划思想是将求解的子问题的最优解给保存下来(记忆化存储)，然后再用到这个子问题的时候就可以直接调用。

而递归思想其实就是将一个问题分解成无数个子问题，通过求解子问题来完成求解问题的操作。

1、C++中

cpp中逻辑运算符与位运算符的区别。

**位运算**：直接对整数在内存中的二进制位进行操作；一般需要运算所有位置的值。
**逻辑运算**：又称布尔运算，对TRUE和FALSE进行操作；一般只需要运算特定位置的值。

逻辑运算符两边只能是bool类型。

位运算符两边既可以是bool类型，又可以是数值类型。

**区别**：

if (A && B) 如果 A 为 false ，整个表达式就为 false，不再计算 B 的值了。
if (A & B) 如果 A 为 false ，整个表达式就为 false，但还要计算 B 的值。
if (A && B++) 如果A 为 false，&&不会再计算后面的值
if (A & B++) 如果A 为 false，&则会计算后面的值

逻辑（AND）： true && false ： false
按位（AND）： 1001 0110 & 1111 1111 ： 1001 0110 （[二进制位])）

逻辑运算符

```cpp
与：&&;
或：||;
非：！
```

位运算符

| 运算符 |     作用     |                  示例                  |
| :----: | :----------: | :------------------------------------: |
|   &    |  **按位与**  |      两个操作数同时为1，结果才为1      |
|   \|   |  **按位或**  |    两个操作只要有一个为1，结果就为1    |
|   ~    |  **按位非**  | 操作数为1，结果为0；操作数为0，结果为1 |
|   ^    | **按位异或** |         两个数不相同结果才为1          |
|   <<   |     左移     |              左侧空位补0               |
|   >>   |     右移     |            左侧空位补符号位            |



2、空指针可以用于逻辑判断

```cpp
	int* a = nullptr;
	if (!a) {
		cout << "helo" << endl;
	}
	//输出hello
```

3、逻辑判断的最简单方式

```cpp
int m = 9;
int n = 10;
int a = m > n ? m : n;
cout << "a=" << a<<endl;//输出最大的数 输出10
```

4、取出容器中的某个数的简单方式

```cpp
string name = "wangming";
	for (char c : name) cout << c << endl;
//输出如下：
w
a
n
g
m
i
n
g
    
// 容器中嵌套容器大小可以不是固定的； 
std::vector<vector<int>> ves;
vector<int> v1 = { 1,2 };
vector<int> v2 = {3,4,5};
ves.push_back(v1);
ves.push_back(v2);
```

5、省略中括号

```cpp
int a = 0;
if (a == 0) cout << "相等" << endl;
//一般情况下圆括号不能省略，但是中括号里面的内容是可以沈略的
```

6、cpp中转换数据类型

```cpp
//cpp中会将不是该数据类型的数据抓换成该数类型
int a=2.1;
int a=2.5;
int a=2.7;
int a=2.9;
cout<<a<<endl;//以上所有的全部输出2；
//cpp会将数据向左取整；
```

7、c++中的min与max

注意只能用来比较两个数

```cpp
int a=0;
int b=5;
cout<<min(a,b)<<endl;
cout<<max(a,b)<<endl;
// 如果需要比较三个数的大小可以通过两个两个分别进行判断。
cout << min(min(a, b), c) << endl;
```

8、C++中的极大值

```cpp
// int类型的极大值与极小值
std::cout << INT_MAX << std::endl;
std::cout << INT_MIN << std::endl;
std::cout << LONG_MAX << std::endl;
std::cout << LONG_MIN << std::endl;
//通过上述方法就给a指定了极大值。
```

9、C++中数学

主要是利用std中的数学来进行求解

```cpp
// pi
std::cout<<M_PI<<std::endl;
// 绝对值
std::cout<<std::abs(-10)<<std::endl;
// 开平方
std::cout << std::pow(10, 2) << std::endl;
// 开根号
std::cout << std::sqrt(100) << std::endl;
//三角函数
std::cout << std::sin(M_PI/2) << std::endl;
std::cout << std::cos(M_PI/2) << std::endl;
std::cout << std::atan2(1, 1) << std::endl;// 反正弦
```

9、Cpp中获取整行控制台输入

```cpp
// 方法一:
# include<iostream>
using namespace std;
string buf;
cout << "Type your input:\n";
getline(cin, buf);// 获取整行的输入
cout << buf;

//方法二：
string buf;
cout << "Type your input:\n";
getline(cin, buf,'.'); //第三个参数是一个字符，表示以'.'作为结尾的标志
cout << buf;

//输出入下面所示
Type your input:
wangming.slmm
wangming
```

10、特别需要注意的是cpp中字符是单引号而不是双引号，这个需要特别注意

```cpp
```

11、C++中的字符串.split函数

```cpp
#include < iostream>
#include <string>
#include <vector>
#include<sstream>

std::vector<std::string> Stringsplit(std::string str, char split)
{
    std::istringstream iss(str);	// 输入流
    std::string token;			// 接收缓冲区
    std::vector<std::string> res_v;
    while (getline(iss, token, split))	// 以split为分隔符
    {
        if (token.size() != 0) {
            res_v.push_back(token);
        }
    }
    return res_v;
}
```

12、C++中输出控制输出精度

```cpp
// 注意头文件以及a都需要控制输出
# include<iomanip>
double a = 3;
std::cout << std::fixed << std::setprecision(5) << a;//输出 0.12300
```

13、C++中字符串和数字之间的转换

```cpp
// string通过索引获得的是char类型的字符串。
std::string str ="wangming";
str[0]是字符型 ”char“类型
std::string str = "9023";
std::cout << typeid(str.substr(0, 1)).name() << std::endl;
// class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >
std::cout << typeid(str[0]).name() << std::endl;  //  char
// ①获得string类型的单个字符
// ②获得char类型的单个字符

// string 转换成 int
std::string a = "62";
int b  = std::stoi(a);          // 转换成int类型
double b2 = std::stod(a);       // 转换成double类型

// int转换成string
int a = 100;
std::string b = std::to_string(a);//int 转换成string


// const char*与char arr[]转换成int类型的数据
const char* a = "1344";
int b = std::atoi(a);

char a[] = "1344";
int b = std::atoi(a);


// char 类型通过ASCII码转化成int类型
char a = '9';
int ia = a - '0';// 直接将该字符与0字符之间的字相减即可获得两个字符之间的
std::cout << ia << std::endl;
```

14、C++中的大写转换、

```cpp
string str = "AwjsjgGg";
char str2 = std::toupper(str[1]);// 转换到大写
char str3 = std::tolower(str[0]);// 转换成小写

std::transform(str.begin(), str.end(), str.begin(),std::toupper);// 将字符串转换成大写
std::transform(str.begin(), str.end(), str.begin(), std::tolower);// 将字符串转化成小写
```



**11、cpp的acm模式输入输出要点**

1、只有一个或者几个输入

```cpp
int main() {
    int a, b, c;
 	// 接收有限个输入
    cin >> a >> b >> c;  //例如输入1 2 3 则会输出6
  	// 输出结果
    cout << a+b+c << endl;
}
```

2、先给元素个数，再给元素

```cpp
// 输入样例
3
3 5 7
6 8 9
12 9 5
```

```cpp
int main() {
    int T;
    vector<int> res;
  	// 拿到输入行数T
    cin >> T;//等价于输入的第一个值赋值给T
  	// 接收T行输入
    while (T--) {
        int a, b, c;
        cin >> a >> b >> c;
        res.push_back(a+b+c);
    }
  	// 输出结果
    for (int n : res) {
        cout << n << endl;
    }
}
//3 1 2 3 6 7 8 9 4 1
//6
//21
//14
```

3、先给元祖个数，再给一行数组

```text
5 2
1 4 2 6 5
2 3
```

```cpp
int main() {
    int n, m;
    cin >> n >> m;//首先赋值给n，再赋值给M
    vector<int> nums(n);
    for (int i=0; i<n; ++i) cin >> nums[i];
    vector<int> lens(m);
    for (int i=0; i<m; ++i) cin >> lens[i];
}
```

4、多组输入，读到文件结束符EOF为止

**方法一**：

不直接告知有多少组输入，而是通过EOF来进行判断

`cin` 读到有数据输入时会返回非0，而读到文件结束符时会返回0，结束while循环。

```cpp
int main() {
    int a, b;//注意一组是两个数
    vector<int> res;
    while (cin >> a >> b) {
        res.push_back(a+b);
    }
}
```

**Windows 系统中，通过键盘输入时，先回车键另起一行后再按 Ctrl+Z 组合键后再按回车键，才能结束。**

在 UNIX/Linus/Mac OS 系统中，**Ctrl+D** 代表输入结束

**方法二：**

`scanf` 读到文件结束符时会返回-1，而-1的补码表示恰好是全1，从而用按位取反得到0，此时结束 while 循环。

```cpp
int main() {
    int a, b;
    vector<int> res;
    while (~scanf("%d%d", &a, &b)) {
        res.push_back(a+b);
    }
}
```

5、字符串的输入和输出

```cpp
//方法一：
int main() {
    const int N = 100;
    char s[N];
    scanf("%s", s);
}

//方法二：
int main() {
    string s;
    cin >> s;//空格之后的将不会在记录,也就是如果你输入 slmm wm,则只会记录slmm,遇到空格就会记录
    cout << s << endl;
}
```



5、保留小数点后面几位数字

1. 如保留 32位小数：`printf("%.2f\n", a);`， 此种方法会自动的四舍五入。
2. 一位小数四舍五入成整数：`float a = 2.7; printf("%d\n", int(a+0.5));`

6、ASCII码值，大写的字母比较小，小写的字母比较大

大小写字符之间的ASCII值相差32

```cpp
// 根据数字字符的值得到数字本身
char small = 'b';
char big = small - 32;
cout << big << endl;//输出的是大写的值
```

12、cpp中acm模式2

==1、固定数目的整形数字==

```cpp
//方法1：固定大小n   优先用方法1
int n;
cin >> n;
vector<int> nums(n);
for (int i = 0; i < n; ++i){
    cin >> nums[i];
}
//方法2：resize大小为n
int n;
cin >> n;
vector<int> nums;
nums.resize(n);
for (int i = 0; i < n; ++i){
    cin >> nums[i];
}
//方法3：vector数组未初始化大小时，只能用push_back方式插入数据  注意  不能vector<int> nums(n)这样默认前n个数为0
int n;
cin >> n;
vector<int> nums;
for (int i = 0; i < n; ++i){
     int val;
     cin >> val;
     nums.push_back(val);
}
```

==2、非固定数目的整形数字，中间以空格（或者其他单字符分隔）==

```cpp
vector<int> nums;
    int num;
    while(cin>>num){
        nums.push_back(num);
        if(getchar() == '\n')
            break;
}

```

==3、输入二维矩阵==

下面是acm输入二维度矩阵的方式

```cpp
int m, n, temp;
cin>>m;
cin>>n;
vector<vector<int>> matrix(m,vector<int>(n));//定义一个m*n行的矩阵
for(int i=0;i<m;i++)
{
    for(int j=0;j<n;j++)
    {
        cin>>temp;
        matrix[i][j]=temp;
    }
}
```



### 1、前缀和数组

```cpp

```

### 2、差分数组

差分数组针对一个区间频繁进行加减操作。

<img src="./asserts/001.png" alt="./asserts/001.png" style="zoom: 50%;" />

```cpp
class solution 
{
public:
	vector<int> modifiedarr(int length, vector < vector<int>>& updates) { //数字前面一般不添加引用传递
		vector<int> diff(length, 0);
		//1、 首先构造差分数组
		for (auto& u : updates) {//遍历updates中的每一个元素
			diff[u[0]] += u[2];
			if (u[1] + 1 < length) {
				diff[u[1] + 1] -= u[2];
			}
		}
		//2、返回总数组
		for (int i = 1; i < length; i++) {
			diff[i] += diff[i - 1];
		}
		return diff;
	}
};
```

### 3、双指针技巧秒杀七道链表题目

双指针指的是左右指针和快慢指针

- 左右指针:两个指针相向或者相背而行
- 快慢指针:两个指针同向而行，一块一慢



对于链表来说，数据结构定义如下：

```cpp
// 单链表通过cpp定义的数据结构如图所示
struct ListNode {
    int val;			//链表里面保存的值
    ListNode *next;		//链表保存的具体地址
    //下面是三个构造函数,通过初始化列表来初始化相关的值
    ListNode() : val(0), next(nullptr) {}   //这样构造的话链表就是一个单节点
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

struct listnode{
    int val;
    listnode* next;
    
}

```

对于链表问题，始终要记得两个解决方法

- 一个是快慢指针的方法

- 另一个方法就是最常用的哨兵节点





#### 0、移除链表元素

[203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)

```cpp
// 移除链表中值等于某个值的函数
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if(head==nullptr) return nullptr;
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* cur = dummy;
        while(cur->next != NULL){
            if(cur->next->val== val){
                cur->next= cur->next->next;
            }
            else{
                cur=cur->next;
            } 
        }
        return dummy->next;
    }
};
```

#### 1、反转链表

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/)

使用栈来反转链表

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* dummy = new ListNode(0);
        stack<ListNode*> sta;
        ListNode* cur = head;
        while(cur!=nullptr){
            sta.push(cur);
            cur = cur->next;
        }
        // 当队列非空时
        cur = dummy;
        while(!sta.empty()){
           cur->next = sta.top();
           cur = cur->next;
           sta.pop();
        }
        cur->next =nullptr;
        return dummy->next;
    }
};
```

使用双指针的方法来反转链表

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // 使用双指针的方法
        ListNode* temp;//临时指针
        ListNode* cur = head;
        ListNode* pre = nullptr;
        while(cur!=nullptr){
            temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
};
```

使用递归的方法来反转链表

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==nullptr) return nullptr;
        if(head->next==nullptr) return head;

        ListNode* rev_ed = reverseList(head->next);
        head->next->next=head;
        head->next = nullptr;
        return rev_ed;
    }
};
```

#### 1、合并两个有序链表

对于链表来说我们一般只需要返回链表头结点的指针，这样一般几乎就可以获得整个链表里面所有的值

```cpp
class Solution {
public:
    //输入的是两个头结点的指针，返回的是合并后的升序链表的头结点的指针
    //输入的两个节点中，如果有一个节点为空指针，则直接返回的是另一个链表头节点的指针
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {//输入的是链表中第一个元素对应的指针
        //创建的这个节点是不能移动的，最后返回的是这一个节点的next，这正好是下一个节点的开始地址值，因为开头是一个默认值。
        // 第一个节点是哨兵节点
        ListNode* pred =new ListNode(-1);//通过new来创建指针就不用创建这个变量的实例化对象辽
        ListNode* p=pred;
        //如果不通过new操作来进行的话
        /*
        ListNode a(-1);
        ListNode* p=&a;
        */
        while(list1!=nullptr && list2!=nullptr)//链表中最后一个元素指向的是空指针
        {
            if(list1->val<list2->val)
            {
                p->next=list1;
                list1=list1->next;
            }
            else
            {
                p->next=list2;
                list2=list2->next;
            }
            p=p->next;
        }
        p->next=(list1==nullptr)?list2:list1;  //后面这里简单判断语句的技巧也需要认真学，括号里面为真就取冒号前面的，括号里面为假就取得括号后面的
        return pred->next;
    }
};
```











#### 2、合并k个升序链表

首先需要知道优先队列这种数据结构

**方法一：采用分而治之的思想**

```cpp
class Solution {
public:
    ListNode* mergeTwolists(ListNode* l1,ListNode* l2)
    {
        ListNode* dummy=new ListNode(-1);//哨兵节点
        ListNode* p = dummy;//两个节点指向的是同一个地址

        while(l1!=nullptr&&l2!=nullptr)
        {
            if(l1->val<l2->val)
            {
                p->next=l1;
                l1=l1->next;
            }
            else
            {
                p->next=l2;
                l2=l2->next;
            }
            p=p->next;
        }
        p->next=((l1==nullptr)? l2:l1);//找到两者中非空的元素
        return dummy->next;
    }
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode* p=nullptr;  //指定这是一个空指针
        for(auto& li:lists)
        {
            p=mergeTwolists(p,li);
        }
        return p;
    }
};
```

**方法二：采用优先队列的方法**

```cpp
struct cmp
{
    // 优先队列本身就是先返回最大的值
    bool operator()(ListNode* a,ListNode* b){
        return (a->val>b->val); // 大于的话最先返回最小的值，小于的话则就是最先返回最大的值
    }
};
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.size()==0) return nullptr;
        ListNode* dummy =new ListNode(0); //定义虚拟头部节点
        ListNode* p = dummy;              //两个指针指向的是同一块内存
        
        priority_queue<ListNode*,vector<ListNode*>,cmp> qu;
        for(auto& li:lists)
        {
            if(li!=nullptr){
                qu.push(li);//将所有的链表都添加到优先队列中
            }
        }
        while(!qu.empty())
        {
            ListNode* node=qu.top();
            qu.pop();
            if(node->next!=nullptr)
            {
                qu.push(node->next);
            }
            p->next=node;
            p=p->next;
        }
        return dummy->next;
    }
};
```

#### 3、删除链表中倒数第n个节点

**方法一：双指针行进**

快慢指针的方法

```cpp
class Solution {
public:
    //这个函数可以当成一个模板，是找到导数第n个节点的指针
    ListNode* findNthNode(ListNode* head, int n){//定义一个函数找到导数第n个节点的指针
        ListNode* p1 = new ListNode(-1,head);//定义一个指向head的
        ListNode* p2 = head;//p2开始比p1往前了一个单位
        for(int i=0;i<n;i++)//p2往前移动n次 先将n往后n个单位然后再进行求解
        {
            p2=p2->next;
        }
        while(p2!=nullptr)
        {
            p2=p2->next;
            p1=p1->next;
        }
        return p1->next;//返回当前节点的地址
    }
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(-1,head);
        //找到前面一个,注意这里传入的是dummy，无论链表开头的地址是多少，我们最终要找到倒数第n,这个都不会有影响的
        //因为链表加长了，往后也会加长。
        auto p=findNthNode(dummy,n+1);
        (p->next)=(p->next->next);
        return dummy->next;
    }
};
```

**方法二：利用数据结构栈来实现**

![](./asserts/002.png)

```cpp
#include<stack>
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(-1,head);
        ListNode* dummy2 =dummy;
        stack<ListNode*> st;
        while(dummy!=nullptr)
        {
            st.push(dummy);//st是一种先进后出
            dummy=dummy->next;
        }
        for(int i=0;i<n;i++)
        {
            st.pop();
        }
        ListNode* res=st.top();
        st.top()->next=st.top()->next->next;
        return dummy2->next;//开始的时候我返回的是head,但是head是会出错的，因为如果输入head只有一个节点，并且删除也是1个的话就会出现出错误。因为head还是有值的；
    }
};
```

#### 4、求得链表的中点

很简单，就是用快慢指针的方法

```cpp
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        //ListNode* dummy = new ListNode(-1,head);
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast!=nullptr&&fast->next!=nullptr) //注意这里里面是&&不是||
        {
            fast=fast->next->next;// 快指针速度是慢指针的两倍。
            slow=slow->next;
        }
        return slow;
    }
};
```

#### 5、判断链表是否包含环

经过试验发现，无论是奇数还是偶数个节点，只要这个链表包含环，那么这个链表的快慢指针之间必定会相遇

注意链表之间的环不一定要首尾相连，有可能是中间存在一个小环

<img src="./asserts/003.jpg" style="zoom:50%;" />

```cpp
// 如果存在环的话快指针和慢指针是一定会相遇的
class Solution {
public:
    bool middleNode(ListNode* head) {
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast!=nullptr&&fast->next!=nullptr) //注意这里里面是&&不是||
        {
            fast=fast->next->next;// 慢指针是快指针的两倍
            slow=slow->next;
            if(slow==fast)  //如果这两个链表之间存在环的话，那么这两个链表之间必定会相遇
            {
                return true;
            }
        }
        return false;
    }
};
```

另一个比较重要的方法就是如果这个链表中包含环，那么这个环的起点在哪里





**方法1:利用哈希表的方法**

用哈希表更好理解也更加简单一点；这里不用哈希表，用C++中自带的set数据类型也可以的。

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        int count=0;
        ListNode* dummy=new ListNode(-1,head);
        unordered_map<ListNode*,int> ma;//定义一个哈希表，利用哈希表的find函数
        while(dummy!=NULL)
        {
            dummy=dummy->next;
            count++;
            //这里的auto其实也可以用下面的迭代器来进行表示unordered_map<ListNode*,int>::iterator
            //auto find=ma.find(dummy);
            if(find!=ma.end())//说明存在相同的元素，因此存在环，如果哈希表中不存在这个键值，则直接返回尾部的迭代器
            {
                return dummy;
            }
            else
            {
                 ma[dummy]=count;
            }
        }
        return NULL;
    }
};
```

**方法2：利用快慢指针的方法**

<img src="./asserts/004.jpg" style="zoom:50%;" />

如图，假设慢指针走了k步，那么快指针就走了2k步，就会存在如上图的几何关系

相遇点之后再让某个指针指向头部，然后继续走，那么肯定会再次 相遇，再次相遇点就是这个环的起点。

相遇点之后再让某个指针指向头部，然后继续走，那么就会再次相遇，再次相遇的这个点就是环的起点。

相遇点之后再让某个指针指向头部，然后继续走，那么就会再次相遇，再次相遇的这个点就是环的起点。

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode * fast = head;
        ListNode * slow = head;
        while(fast!=NULL&&fast->next!=NULL) //不是结尾的空指针也不是链表中的最后一个元素的
        {
            fast=fast->next->next;
            slow=slow->next;
            if(slow==fast)//如果发现两个相等，说明一圈辽
            {
                fast=head;//重新指向头节点
                while(fast!=slow)
                {
                    slow=slow->next;
                    fast=fast->next;
                }
                return fast;
            }
        }
        return NULL;//如果能够跳出循环，则必然能够说明链表中存在空指针，说明该链表是无环的，因此还是存在问题
    }
};
```

#### 6、判断链表是否存在环

**1、利用C++中的set容器**

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        set<ListNode *> se;//定义一个set容器
        while(headA!=NULL&&headB!=NULL)//两个都需要指向具体元素
        {
            auto po=se.find(headA);
            if(po!=se.end()) return headA;
            se.insert(headA);
            po=se.find(headB);
            if(po!=se.end())//如果存在两个相等的
            {
                return *po;
            }
            else
            {
                se.insert(headB);
                headA=headA->next;
                headB=headB->next;
            }
        }
        auto p=(headA==NULL?headB:headA);
        while(p!=NULL)
        {
            auto po=se.find(p);
            if(po!=se.end()) return p;
            se.insert(p);
            p=p->next;
        }
        return NULL;      
    }
};
```

**2、双指针的方法**

将两个链表首尾相连

<img src="./asserts/005.jpg" style="zoom:50%;" />

<img src="./asserts/006.jpg" style="zoom:50%;" />

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA==NULL||headB==NULL) return NULL;
        ListNode * pa= headA;
        ListNode * pb= headB;
        while(pa!=pb)
        {
            pa=pa==NULL?headB:pa->next;
            pb=pb==NULL?headA:pb->next;
        }
        return pa;    
    }
};
```

#### 7、判断链表是否相交

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221723.png" alt="img" style="zoom:50%;" />

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* curA = headA;
        ListNode* curB = headB;
        int lenA = 0, lenB = 0;
        while (curA != NULL) { // 求链表A的长度
            lenA++;
            curA = curA->next;
        }
        while (curB != NULL) { // 求链表B的长度
            lenB++;
            curB = curB->next;
        }
        curA = headA;
        curB = headB;
        // 让curA为最长链表的头，lenA为其长度
        if (lenB > lenA) {
            swap (lenA, lenB);
            swap (curA, curB);
        }
        // 求长度差
        int gap = lenA - lenB;
        // 让curA和curB在同一起点上（末尾位置对齐）
        while (gap--) {
            curA = curA->next;
        }
        // 遍历curA 和 curB，遇到相同则直接返回
        while (curA != NULL) {
            if (curA == curB) {
                return curA;
            }
            curA = curA->next;
            curB = curB->next;
        }
        return NULL;
    }
};
```













### 4、双指针处理数组问题

双指针包括**左右指针**和**快慢指针**

由于数组中并不存在指针，所以我们用索引来代替

**快慢指针**主要见123，主要是为了让我们原地修改数组。

#### 1、删除有序数组的重复项

leetcode26题，删除有序数组的重复项；

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size()==0)//为空的话直接返回0
        {
            return 0;
        }
        int a=0; int b=0;//定义两个指针
        while(b<nums.size()){
            if(nums[a]!=nums[b])//如果两个数组不相等的话
            {
                a++;
                nums[a]=nums[b];
            }
            b++;
        }
        return a+1;
    }
};
```

#### 2、同上，但是是链表

```cpp
// 单链表通过cpp定义的数据结构如图所示
struct ListNode {
    int val;			//链表里面保存的值
    ListNode *next;		//链表保存的具体地址
    //下面是三个构造函数,通过初始化列表来初始化相关的值
    ListNode() : val(0), next(nullptr) {}   //输入为0
    ListNode(int x) : val(x), next(nullptr) {}//输入为一个值，最后表示成单链表
    ListNode(int x, ListNode *next) : val(x), next(next) {}//输入一个值和一个链表
};
```



leetcode83

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head==nullptr) return nullptr;
        ListNode* slow= head;
        ListNode* fast= head;
        while(fast!=nullptr)//当下一个元素不等于空指针
        {
            if(fast->val!=slow->val)
            {
                slow->next=fast;
                slow=slow->next;
            }
            fast=fast->next;
        }
        slow->next=nullptr;
        return head;
    }
};
```



#### 3、原地删除某些元素

leetcode27题

数组可能没有顺序

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        if(nums.size()==0) return 0;
        int slow=0,fast=0;//定义
        while(fast<nums.size())
        {
            if(nums[fast]!=val)
            {
                nums[slow]=nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```

leetcode283

```python
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int a=0;
        int b=0;
        while(b<nums.size())
        {
            if(nums[b]!=0)
            {
                nums[a]=nums[b];
                a++;
            }
            b++;
        }
        while(a<nums.size())
        {
            nums[a]=0;
            a++;
        }
    }
};

```

**左右指针**



#### 4、leetcode 167

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0;//最右边的
        int right = numbers.size()-1;//最左边的
        while(left<right)
        {
            if(numbers[left]+numbers[right]==target)
            {
                return {left+1,right+1};
            }
            else if(numbers[left]+numbers[right]<target)
            {
                left++;
            }
            else{
                right--;
            }
        }
        return {0,0};
    }
};
```



#### 5、反转字符串

leetcode344

```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left=0;
        int right=s.size()-1;
        while(left<right)
        {
            auto tem=s[left];
            s[left]=s[right];
            s[right] = tem;
            left++;
            right--;
        }
    }
};
```



#### 6、最长回文字符串

```cpp
class Solution {
public:
    string res(int l,int r, string str)
    {
        while(l>=0&&r<str.size()&&str[l]==str[r])
        {
            l--;
            r++;
        }
        int n=r-l-1;
        return str.substr(l+1,n);//注意这个函数的意思是从l+1位置开始，往后数n个字符串，并不是开头与结尾的位置
    }
    string longestPalindrome(string s) {
        string res_str;
        string s1,s2;
        for(int i=0;i<s.size();i++)
        {
            s1=res(i,i,s);
            s2=res(i,i+1,s);
            if(res_str.size()<s1.size())
            {
                res_str=s1;
            }

            if(res_str.size()<s2.size())
            {
                res_str=s2;
                
            }
        }
        return res_str;
    }
};
```

### 5、滑动窗口法

滑动窗口法多用于处理字符串

一般的解题套路如下：

```cpp
void slidinngWindow(string s)
{
    unordered_map<char,int> window;
    int left=0,right=0;//左右窗户的索引全部都设置为0
    
    while(right<s.size())
    {
        char m = s[right];  //左闭右开区间
        right++;
        /*
        更新窗口
        */
        
        while(收缩窗口大小)
        {
            char n=s[left];
            left--;
            /*
            更新窗口
            */
            
        }
    }
}
```

#### 1、最小覆盖子串

leetcode 76题 **困难**

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
    unordered_map<char,int> window,need;//need 里面保存窗口里面需要的东西
    int left=0,right=0;
    int record=0;//用于记录满足条件的个数
    int pos=0,max_len=10e5;//这就是最终返回的字符串的位置以及长度
    
    for(char c:t) need[c]++;//更加简洁
    
    while(right<s.size())
    {
        char m=s[right];
        right++;
        if(need.count(m))//注意这里是圆括号
        {
            window[m]++;
            if(window[m]==need[m]) record++;
        }
        while(record==need.size())
        {
            if(right-left<max_len)
            {
                max_len=right-left;
                pos=left;
            }
            char n=s[left];//在窗口中将这个数去掉
            left++;
            if(need.count(n))//如果去掉的这个字母是需求里面的
            {
                if(window[n]==need[n])
                {
                    record--;
                }
                window[n]--;
            }
        }
    }
    return max_len==10e5? "":s.substr(pos,max_len);//如果不存在的话返回空的字符串
    }
};
```

#### 2、字符串排列

leetcode567 **中等**

```cpp
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        int left=0,right=0;
        int len=s1.size();//需要满足条件的字符的个数
        int record=0;
        unordered_map<char,int> window, target;
        
        for(int i=0;i<s1.size();i++)
        {
            target[s1[i]]++;
        }

        while(right<s2.size())//my到达边界
        {
            char m = s2[right];
            right++;
            
            if(target.count(m))//增加的字符串如果在目标中
            {
                window[m]++;//向窗口中增加当前的这个数
                if(window[m]==target[m])
                {
                    record++;
                }
            }
            while(right-left==len)//当前窗口的尺寸和s1字符串相等
            {
                if(target.size()==record)
                {
                    return true;
                }

                char n = s2[left];
                left++;
                if(target.count(n))
                {
                    if(window[n]==target[n])
                    {
                        record--;
                    }
                    window[n]--;//向窗口中减小当前这个数
                }
            }
        }
        return false;
    }
};
```

leetcode 2062

### 6、二分搜索

#### 1、最简单的查找一个数

leetcode 704

因为我们初始化 **right = nums.length - 1** 所以决定了我们的「搜索区间」是 **[left, right]** 所以决定了 **while (left <= right) **同时也决定了 **left = mid+1** 和 **right = mid-1** 因为我们只需找到⼀个 target 的索引即可 所以当 nums[mid] == target 时可以⽴即返回

```cpp
int search(vector<int>& nums, int target) {
	int res=-1;
	int left=0, right=nums.size()-1;  //定义了搜索区间为[left,right]
	int mid = left+(right-left)/2;    //定义中间的元素,这样的写法可以防止元素溢出
	while(left <= right)              
	{
		int mid = left+(right-left)/2;
		if(nums[mid]==target)
		{      
			return mid;
        }
        else if(nums[mid]>target)
        {
            right=mid-1;
         }
        else if(nums[mid]<target)
        {
                left=mid+1;
        }
   }
        return res;
    }
```

#### 2、寻找左侧边界

因为我们初始化 **right = nums.length** 所以决定了我们的「搜索区间」是**[left, right)** 所以决定了 **while (left < right)** 同时也决定了**left = mid + 1** 和 **right = mid** 因为我们需找到 target 的最左侧索引 所以当 nums[mid] == target 时不要⽴即返回 ⽽要收紧右侧边界以锁定左侧边界

```cpp
int left_bound(int[] nums, int target) {
	int left = 0, right = nums.length - 1;
	while (left <= right) 
    {
		int mid = left + (right - left) / 2;
		if (nums[mid] < target) 
        {
			left = mid + 1;
		} 
        else if (nums[mid] > target) 
        {
			right = mid - 1;
		} 
        else if (nums[mid] == target) 
        {
			// 别返回，锁定左侧边界
 			right = mid - 1;
 		}
 	}
    // 最后要检查 left 越界的情况
    //left是一直增加的，所以要判断他是否超过上界
    if (left >= nums.length || nums[left] != target) 
        return -1;
    return left;
	}
```



#### 3、寻找右侧边界

```cpp
int right_bound(int[] nums, int target) {
	int left = 0, right = nums.length - 1;
	while (left <= right) {
		int mid = left + (right - left) / 2;
		if (nums[mid] < target)
        {
			left = mid + 1;
		} 
        else if (nums[mid] > target) 
        {
			right = mid - 1;
		} 
        else if (nums[mid] == target)
        {   // 别返回，锁定右侧边界
			left = mid + 1;
		}
	}
	// 最后要检查 right 越界的情况
    if (right < 0 || nums[right] != target)
        return -1;
    return right;
}

```

因为我们初始化**right = nums.length**所以决定了我们的「搜索区间」是 **[left, right)** 所以决定了 **while (left < right)** 同时也决定了 **left = mid + 1** 和 **right = mid** 因为我们需找到 target 的最右侧索引 所以当 **nums[mid] == target** 时不要⽴即返回 ⽽要收紧左侧边界以锁定右侧边界 ⼜因为收紧左侧边界时必须 left = mid + 1 所以最后⽆论返回 left 还是 right，必须减⼀



#### 4、在排序数组中查找元素的第一个和最后一个位置

leetcode34题

```cpp
class Solution {
public:
    //下面这个就是通用类型的二分法
    int binary(vector<int>& nums, int target, string flag)
    {
        int left=0,right=nums.size()-1;  //定义左右边界的具体值
        while(left<=right)
        {
            int mid=left+(right-left)/2;
            if(nums[mid]==target)
            {
                if(flag=="left")
                {
                    right=mid-1;
                }
                else if(flag=="right")
                {
                    left=mid+1;
                }
            }
            else if(nums[mid]<target)
            {
                left=mid+1;
            }
            else if(nums[mid]>target)
            {
                right=mid-1;
            }
        }
        if(flag=="left")
        {
            if(left>=nums.size()||nums[left]!=target) return -1;
            return left;
        }
        else
        {
            if(right<0||nums[right]!=target) return -1;
            return right;
        }
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        int left=binary(nums,target,"left");
        int right=binary(nums,target,"right");
        return vector<int> {left,right};
    }
};
```



### 7、田忌赛马背后的算法决策

将**齐王**和**田忌**的马按照战斗力排序，然后按照排名一一对比。如果田忌的马能赢，那就比赛，如果赢不了，那就换个垫底的来送人头，保存实力。

```cpp
class Solution {
public:
struct NumIndex{
    int val;//该结构体对应的值
    int index;//该结构体对应的索引
    bool operator< (const NumIndex &ele) const  //两个const都不能少
    {
        return this->val<ele.val;//返回最大值
    }
};
    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {
        vector<int> v(nums1.size());//v必须首先指定容量
        priority_queue<NumIndex> q2;
        for(int i=0;i<nums2.size();i++)
        {
            q2.push({nums2[i],i});
        }
        sort(nums1.begin(),nums1.end());//将num1从小到大进行排序
        int left=0,right=nums1.size()-1;
        while(!q2.empty())//当q2不为空的时候
        {
            if(q2.top().val<nums1[right])
            {
                v[q2.top().index]=nums1[right];
                right--;
            }
            else
            {
                v[q2.top().index]=nums1[left];
                left++;
            }
            q2.pop();
        }
        return v;
    }
};
```



### 8、动态规划

动态规划问题三要素：

- **重叠⼦问题**：用DP table数组来保存

- **最优⼦结构**：能否通过子问题的最值来找到原问题的最值

- **状态转移⽅程**

一般是三个步骤：

1、定义数组元素的含义

2、找到数组元素之间的关系式

3、找出初始值



#### 8.1 机器人走路

**机器人走路问题。也即是从左上角走到右下角，一共有多少种不同的走路方法。**

注意：如果网格只有一行的话，相当于从左边走到右边，也就是只有一种方法，因为只能一步一步往右边行走这一种方法。

同理，如果只有一列的话，同理也就是只有一种方法，也就是从上面往下行走。

本问题中dp数组的含义就是从左上角走到i行j列位置需要走多少步。

注意这里并不是求得有多少步，而是求得需要行走多少步。

[62. 不同路径 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths/)

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n)); //一个二维容器的dp数组，并没有指定默认值
        for(int i=0;i<m;i++)
        {
            dp[i][0]=1;//指定默认值,只能一直往下走，所以只有一种方法
        }
        for(int j=0;j<n;j++)
        {
            dp[0][j]=1;//只能一直往右走，只有这一种方法
        }
        
        for(int i=1;i<m;i++)
        {
            for(int j=1;j<n;j++)
            {
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];// 就是右下角具体的
    }
};
```

题目2：最小路径

[64. 最小路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-path-sum/description/)

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> dp(m,vector<int>(n,0));// dp[i][j]表示从左上角到i,j位置的最小路径和
        dp[0][0] = grid[0][0];// 这里需要注意一下。
        for(int i=1;i<n;i++) dp[0][i] = dp[0][i-1]+grid[0][i];
        for(int j=1;j<m;j++) dp[j][0] = dp[j-1][0]+grid[j][0];

        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i][j];// 从上面或者左面最小的一条路下来
            }
        }
        return dp[m-1][n-1];
    }
};
```

#### 8.2 编辑距离

[72. 编辑距离 - 力扣（LeetCode）](https://leetcode.cn/problems/edit-distance/description/)

1、定义数组元素的含义

word1的长度为i， word2的长度为j时，求得将word1转化为word2所使用的最少操作次数。dp [i ] [j]

 `D[i][j]` 表示 `A` 的前 `i` 个字母和 `B` 的前 `j` 个字母之间的编辑距离。

有两个定义：

定义1：如果其中一个字符串为空，那么变成另外一个字符串就等于不为空的另外一个字符串的长度。

定义2：当两个字符串都不为空的时候，dp [i] [j] =min(dp[i-1] [j]+1, dp[i] [j-1]+1, dp[i-1] [j-1]+int(word1[i]!=word2[j]))

也即是dp数组的定义有三种情况：

```cpp
dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+int(word1[i]!=word2[j]))
dp[i-1][j]：情况一
dp[i][j-1]+1：情况二
dp[i-1][j-1]+int(word1[i]!=word2[j])：情况三
```

word1 = "abcde", word2 = "fgh"

- 情况1：知道abcd转换到fgh最少x步，那么abcde抓换到fgh一共是x+1步

- 情况2：知道abcde转换到fg最少x步，那么abcde转换到fgh一共是x+1步

- 情况3：知道abcd抓换到fg最少x步，那么abcde转换到fg一共是x+1步，但是如果剩下的一个字母是相同的话，也即是e和h如果是相同的话，那么则需要x步，因为最后一步并不需要怎么判断.

  ```cpp
  class Solution {
  public:
      int minDistance(string word1, string word2) {
          if(word1.size()==0||word2.size()==0) return word1.size()+word2.size();
          int m = word1.size();
          int n = word2.size();
          vector<vector<int>> dp(m+1,vector<int>(n+1));
          for(int i=0;i<m+1;i++) dp[i][0]=i;
          for(int j=0;j<n+1;j++) dp[0][j]=j;
  
          for(int i=1;i<m+1;i++){
              for(int j =1;j<n+1;j++){
                 if(word1[i-1]==word2[j-1]){// 如果两个字符相等的话
                     dp[i][j] = dp[i-1][j-1];
                 } else{
                      int case1 = dp[i-1][j]+1;	// 删除
                      int case2 = dp[i][j-1]+1;	// 插入
                      int case3 = dp[i-1][j-1]+1; // 替换
                      dp[i][j]=min(case1,min(case2,case3));
                 }
              }
          }
          return dp[m][n];
      }
  };
  ```

#### 8.3 兑换零钱

最少硬币个数以及硬币组合数



[322. 零钱兑换 - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change/)

给定一系列的硬币以及一个整数amount，求出凑成amount的**最少硬币个数**

dp数组的含义是凑成i（也就是amount）的最少硬币个数。

所以递推方程就等价于dp[amount]=dp[amount-coin]+1

同一个amount会存在coins.size()个递推方程。也就是

min(dp[amount-coin1]+1, dp[amount-coin2]+1, dp[amount-coin3]+1,...)

取上述中最小的一个。

还有一个需要注意的点是给出的硬币其中最小的面值是1，dp[amount]的值必然会小于amount(也就是都以1元硬币来兑换)，所以amount+1对于每一个dp[amount]来说就是一个无穷大的值，dp[amount]的值必然会小于dp[amount+1]，

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        //题目中已经给出来了1 <= coins[i],所以每一个amount的最少硬币个数一定小于amount个数
        //amount+1相当于一个无穷大
        // 凑成总额为amount的最少硬币个数 
       vector<int> dp(amount+1,amount+1);//dp[i]表示凑成i的最小硬币个数
       dp[0]=0;
       for(int i=1;i<amount+1;i++)
       {  
           for(auto ele:coins)
           {
               if(i>=ele)  //，只有金额大于硬币面试的时候才可以考虑,这个时候才可以考虑这种情况。
               {
                   dp[i]=min(dp[i-ele]+1,dp[i]);//这里必须有一个比较，因为同一个i对应着多个面值的硬币相加，所以
               }
           }
       }
       return dp[amount]>amount? -1:dp[amount]; 
    }
};
```

下面是零钱兑换II：

[518. 零钱兑换 II - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change-ii/)



给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

此处对应着完全背包的问题。

```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        // dp[i][j]如果只使用coins的前i个硬币的面值，想凑出金额j,有dp[i][j]种方法
        vector<vector<int>> dp(coins.size()+1,vector<int>(amount+1,0));
        for(int i = 0;i<=coins.size();i++) dp[i][0] = 1;

        for(int i=1;i<coins.size()+1;i++){
            for(int j=1;j<amount+1;j++){
                if(coins[i-1]>j){// 当前面额过大，大于目标值
                    dp[i][j] = dp[i-1][j];
                }
                else{
                    dp[i][j] = dp[i][j-coins[i-1]]+dp[i-1][j];//这里会较为不同
                    // dp[i][j-coins[i-1]]也是允许使用第i个硬币的，已经包含了重复使用硬币的情况
                    // 
                }
            }
        }

        return dp[coins.size()][amount];
    }
};
```



#### 8.4 下降路径的最小和

[931. 下降路径最小和 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-falling-path-sum/description/)

leetcode931，求出下降路径的最小和。

给定一个n*n的矩阵，找出该矩阵中下降路径的最小和。

这个其实有点类似于找到最短路径的问题。

```cpp
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
        // 需要求得下降路径的最小和
        int n = matrix.size();// 求得下降路径的最小和
        vector<vector<int>> dp(n, vector<int>(n));    // do[i][j]表示以i j结尾的最小下降路径和
        for(int i=0;i<n;i++) dp[0][i] = matrix[0][i]; // 对于第0行全部赋予初始值
        
        for(int i =1;i<n;i++){   // 逐行添加初始值
            for(int j=0;j<n;j++){
                // 为开始的时候
                if(j==0){
                    dp[i][j] = min(dp[i-1][j],dp[i-1][j+1])+matrix[i][j];
                }
                else if(j==n-1){// 末尾的时候
                    dp[i][j] = min(dp[i-1][j],dp[i-1][j-1])+matrix[i][j];
                }
                else{
                    dp[i][j] = min(dp[i-1][j],min(dp[i-1][j-1],dp[i-1][j+1]))+matrix[i][j];
                }
            }
        }
        return *min_element(dp[n-1].begin(),dp[n-1].end());
    }
};
```

#### 8.5 最小路径和

[64. 最小路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-path-sum/)

定义dp数组的含义为从左上角到到(i,j) 位置所需要的最小路径。

这种最小路径问题其实都比较简单

```python
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> dp(m,vector<int>(n,0));
        dp[0][0] = grid[0][0];
        for(int i=1;i<n;i++) dp[0][i] = dp[0][i-1]+grid[0][i];
        for(int j=1;j<m;j++) dp[j][0] = dp[j-1][0]+grid[j][0];

        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i][j];
            }
        }
        return dp[m-1][n-1];
    }
};
```

#### 8.6 0/1背包问题

给你一个可装载重量为 `W` 的背包和 `N` 个物品，每个物品有重量和价值两个属性。其中第 `i` 个物品的重量为 `wt[i]`，价值为 `val[i]`，现在让你用这个背包装物品，最多能装的价值是多少？

```cpp
#include <iostream>
using namespace std;
# include<vector>

int main() {
    int v,n;// 容量为v，物体个数为n
    cin>>v;
    cin>>n;
    vector<int> volumn;// 每一件物体占用的价值
    volumn.resize(n);
    vector<int> value;
    value.resize(n);
    for(int i=0;i<n;i++){
        cin>>volumn[i];// 体积
        cin>>value[i]; // 价格
    }
    // 对于前i个物体，当前背包容量为w所能装的最大价值
    // dp[i][w]数组的含义是对于前i个物品，当前背包容量为w所能装的最大价值。
    vector<vector<int>> dp(n+1,vector<int>(v+1,0));// 在i为0或者w为0的情况下该题目为0
    for(int i=1;i<=n;i++){
        for(int j=1;j<=v;j++){
            // 当前背包容量装不下第i个物体(不装第i个物体时)
            if(j-volumn[i-1]<0){
                dp[i][j] = dp[i-1][j];// 当前背包装第i-1个物体一样
            }
            else{// 在装这个物体和不装这个物体中选择最大的
                dp[i][j] = std::max(dp[i-1][j-volumn[i-1]]+value[i-1],dp[i-1][j]);

            }

        }
    }
    std::cout<<dp[n][v]<<std::endl;
}
```

②子集背包问题

​		给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

[416. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/description/)

将数组中每一个元素看成是背包的容量，问是否恰好将背包装满。

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(int x:nums) sum+=x;
        if(sum%2!=0) return false;
        // dp[i][j]表示前i个元素，能否找到和为j的岗位
        vector<vector<bool>> dp(nums.size()+1, vector<bool>(sum+1,false));
        for(int i=0;i<=nums.size();i++){
            dp[i][0] = true;
        }
        for(int i=1;i<nums.size()+1;i++){
            for(int j=1;j<sum+1;j++){
                if(j<nums[i-1]){
                    dp[i][j] = dp[i-1][j];
                }
                else{
                    dp[i][j] = dp[i-1][j-nums[i-1]]||dp[i-1][j];
                }
            }
        }
        return dp[nums.size()][sum/2];
    }
};
```

③完全背包





#### 8.7 求得最长递增子序列的长度

[300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/)

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size()==0) return 0;
        // dp[i]表示以nums[i]结尾的子序列的长度
        vector<int> dp(nums.size(),1);
        for(int i=0;i<nums.size();i++){//从0开始
            for(int j = 0;j<i;j++){
                if(nums[i]>nums[j]) dp[i] = max(dp[i],dp[j]+1);
            }
        }

        return *max_element(dp.begin(),dp.end());
    }
};
```

#### 8.8 单词拆分

[139. 单词拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/word-break/)

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。

方法一：通过回溯的方法来做(可能会超出时间)

```cpp
class Solution {
public:
    bool flag = false;
    bool wordBreak(string s, vector<string>& wordDict) {
        string str = "";
        backtrance(wordDict,s,str,0);
        return flag;
    }
    void backtrance(vector<string>& wordDict, string &target, string cur_str, int index){
        if(cur_str.size()>target.size()){
            return;
        }
        if(target==cur_str){
            flag = true;
            return;
        }
        for(string str:wordDict){
            if(target.substr(index,str.size())!=str) continue;// 判断当前str能否加进总体string中
            if(flag) return;
            backtrance(wordDict,target,cur_str+str,index + str.size());
        }

    }
};
```

方法二：通过动态规划的方式来做

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        vector<bool> dp(s.size()+1);// dp[i]表示s的前i个字符能否被字典所表示,可以的话就设置为true。
        dp[0] = true;// 空字符肯定能够被表示
        unordered_set<string> s_set;
        for(auto x:wordDict){
            s_set.insert(x);
        }
        for(int i=1;i<s.size()+1;i++){
            // 判断字符串中的前i个字符
            for(int j=0;j<i;j++){
                if(dp[j]&&s_set.count(s.substr(j,i-j))==1){
                    dp[i]=true;
                    break;
                }
            }
        }
        return dp[s.size()];
    }
};
```

#### 8.9 单词拆分II

给定一个字符串 `s` 和一个字符串字典 `wordDict` ，在字符串 `s` 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。**以任意顺序** 返回所有这些可能的句子。

[140. 单词拆分 II - 力扣（LeetCode）](https://leetcode.cn/problems/word-break-ii/)

同时需要我们来记录最终返回的结果

方法1：通过回溯算法来做

```cpp
class Solution {
public:
    // 利用回溯算法来做第一题
    vector<string> res;
    vector<string> wordBreak(string s, vector<string>& wordDict) {
        string cur_str = "";
        string res_str = "";
        backtrance(wordDict,cur_str,s,res_str,0);
        return res;
    }

    void backtrance(vector<string>& wordDict, string cur_str, string &target, string res_str, int index){
        if(cur_str.size()>target.size()) return;
        if(cur_str==target) res.push_back(res_str.substr(0,res_str.size()-1));// 添加时需要去掉最后一个空格
        // 从单词字典中随机选取一个
        for(string str:wordDict){
            if(target.substr(index,str.size())!=str) continue;
            backtrance(wordDict,cur_str+str,target,res_str+str+" ",index+str.size());
        }
    }
};
```

方法2：通过动态规划的方法来做

```cpp
```

#### 8.10 最大子数组

[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/)

求得子数组中和最大的那一段

1.动态规划的方法

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // dp[i]表示以nums[i]结尾的最大连续子数组
        vector<int> dp(nums.size());// 每一个位置的最大和为其本身
        dp[0] = nums[0];            // 和上面的方法是一样的
        for(int i=1;i<nums.size();i++){	// 这比前面的更加简单，只有一层循环，也是取得最长的那一段
            dp[i] = max(nums[i],dp[i-1]+nums[i]);
        }
        return *max_element(dp.begin(),dp.end());
    }
};
```

2.使用前缀和数组来进行求解

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
    // 利用前缀和数组来求解问题
    vector<int> presum(nums.size()+1);// 前缀和数组
    presum[0] = 0;
    for(int i =1;i<nums.size()+1;i++){// 构造好前缀数组
        presum[i] =  presum[i-1] + nums[i-1];
    }
    int max_value = INT_MIN;// 记录前缀和中的最小孩子
    int min_value = INT_MAX;// 记录
    for(int i=0;i<nums.size();i++){
        min_value = min(min_value,presum[i]);// 求得前缀和中前i个元素的最小值
        max_value = max(max_value,presum[i+1]- min_value);
    }
    return max_value;
    }
};
```

3.滑动窗口的方法

如果nums中全是负数的话，此时算法是可以得到正确答案的，如果nums中有正有负，这种情况下元素和最大的那个子数组一定是以正数开头的。所以这个算法的含义就是遍历所有以正数开始的数组。

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int left = 0,right = 0;
        int window_sum = 0;
        int max_sum = INT_MIN;
        while(right<nums.size()){
            window_sum+=nums[right];
            right++;
            max_sum=max(window_sum,max_sum);

            while(window_sum<0){
                window_sum-=nums[left];
                left++;
            }
        }
        return max_sum;
    }
};
```

#### 8.11 最长公共子序列

求得两个字符串之间的最长公共子序列

[1143. 最长公共子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-subsequence/)

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        // 0表示已经对其赋予了初始值
        int m = text1.size();
        int n = text2.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));// dp[i][j]表示text1的前i个字符与text2的前j个字符之间的最长公共子序列
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                // 如果恰巧前一个是相同的话
                if(text1[i]==text2[j]){
                    dp[i+1][j+1] = dp[i][j]+1;
                }
                else{// 则
                    dp[i+1][j+1] = max(dp[i][j+1],dp[i+1][j]);
                }
            }
        }
        return dp[m][n];
    }
};
```

#### 8.12 两个字符串之间的删除操作

[583. 两个字符串的删除操作 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-operation-for-two-strings/)

这一题和编辑距离几乎是一样的

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size();
        int n = word2.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1));
        dp[0][0] = 0;
        for(int i=0;i<=m;i++) dp[i][0] = i;
        for(int j=0;j<=n;j++) dp[0][j] = j;

        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(word1[i-1]==word2[j-1]){
                    dp[i][j] = dp[i-1][j-1];// 如果两者相等，则操作数不发生改变
                }
                else{
                    dp[i][j] = min(dp[i-1][j-1]+2,min(dp[i-1][j]+1,dp[i][j-1]+1));
                }
            }
        }
        return dp[m][n];// 最终返回的即使递归数组中的值
    }
};
```

#### 8.13 两个字符串之间的最小ASCII码

[712. 两个字符串的最小ASCII删除和 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/description/)

要求和前面这一题基本上是一样的。只加入了ASCII吗值

```cpp
class Solution {
public:
    int minimumDeleteSum(string s1, string s2) {
        int m = s1.size();
        int n = s2.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1));
        dp[0][0] = 0;
        for(int i=1;i<=m;i++) dp[i][0] = dp[i-1][0]+(int)s1[i-1];
        for(int j=1;j<=n;j++) dp[0][j] = dp[0][j-1]+(int)s2[j-1];

        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(s1[i-1]==s2[j-1]){
                    dp[i][j] = dp[i-1][j-1];
                }
                else{
                    int case1 = dp[i-1][j-1]+(int)s1[i-1]+(int)s2[j-1];
                    int case2 = dp[i-1][j] + (int)s1[i-1];
                    int case3 = dp[i][j-1] + (int)s2[j-1];
                    dp[i][j] = min(case1,min(case2,case3));
                }
            }
        }
        return dp[m][n];
    }
};
```

#### 8.14 最长回文子序列(最长回文子串)

<img src="https://pic.leetcode-cn.com/1600677121-aGPcPu-file_1600677121456" alt="img" style="zoom:50%;" />



按照第二种方向进行遍历。



[516. 最长回文子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-subsequence/)

```cpp
// 定义dp[i][j]表示nums[i...j]之间字符串之间的最长回文子序列
// 求结果即为dp[0...n-1]的最长回文子序列
class Solution {
public:
    int longestPalindromeSubseq(string s) {// 这里是返回最长回文子序列的长度
        int n = s.size();
        vector<vector<int>> dp(n,vector<int>(n,0));// n*n
        for(int i=0;i<n;i++) dp[i][i] = 1;
        for(int i = n-1;i>=0;i--){
            for(int j = i+1;j<n;j++){
                if(s[i]==s[j]){
                    dp[i][j] = dp[i+1][j-1]+2;
                }
                else{
                    dp[i][j] = max(dp[i][j-1],dp[i+1][j]);
                }
            }
        }

        return dp[0][n-1];
    }
};
```

注意子串是连续的，而子序列不是连续的（注意这里有两种求解方法）

方法一：中心扩散的方法.

依次遍历每个字符，然后依次将字符中的每一个元素，分别以奇数和偶数向两边进行遍历。

```cpp
class Solution {
public:
    int max_len = INT_MIN;
    pair<int,int> expand(string &str,int left, int right){
        while(left>=0&&right<str.size()&&str[left]==str[right]){
            left--;
            right++;
        }
        return {left+1,right-1};
    }

    string longestPalindrome(string s) {
        int start = 0;
        int end = 0;
        if(s.size()==0) return "";
        for(int i=0;i<s.size();i++){
            pair<int,int> single_e = expand(s,i-1,i+1);
            pair<int,int> double_e = expand(s,i,i+1);
            if(single_e.second-single_e.first>end-start){
                start = single_e.first;
                end = single_e.second;
            }
            if(double_e.second-double_e.first>end-start){
                start = double_e.first;
                end = double_e.second;
            }
        }

        return s.substr(start,end-start+1);
    }
};
```

方法二：动态规划的方法求解回文子字符串

动态规划的方法比较难以理解，还是算了不要重复动态规划的方法

```cpp
class Solution {
public:
    // 下面用动态规划的方法进行求解
    string longestPalindrome(string s) {
        if(s.size()==1) return s;
        if(s.size()==2&&s[0]==s[1]) return s;
        vector<vector<int>> dp(s.size(),vector<int>(s.size(),0));// 0表示不能构成回文子字符串
        for(int i=0;i<s.size();i++) {
            dp[i][i] = 1;// 对角线上的元素都可以获得
            if(i<s.size()-2){
                if(s[i]==s[i+1]) dp[i][i+1]=1;
            }
        }
        int start=0;
        int end=0;
        for(int i = s.size()-1;i>=0;i--){
            for(int j = i+2;j<s.size();j++){
                if(dp[i+1][j-1]==1&&s[i]==s[j]){
                    dp[i][j]=1;
                }
            }
        }
        for(int i = s.size()-1;i>=0;i--){
            for(int j = i;j<s.size();j++){
                if(j-i>end-start&&dp[i][j]==1){
                    start = i;
                    end = j;
                }
            }
        }

        return s.substr(start,end-start+1);
    }
};
```







华为笔试题

```cpp
// we have defined the necessary header files here for this problem.
// If additional header files are needed in your program, please import here.

int main()
{
    // please define the C++ input here. For example: int a,b; cin>>a>>b;;
    // please finish the function body here.
    // please define the C++ output here. For example:cout<<____<<endl;
    string str;
    while(getline(cin,str))
    {
        int N = str.size();
        int space = 0;
        double ans=0;
        for(int i=0;i<N;i++)
        {
            if(str[i]==' ') space++;
        }
        
        ans = 1.0*(N-space)/(space+1);
        printf("%.2lf",ans);
    }
    return 0;
}




string s;
getline(cin,s);//获取控制太中一排数据
cout<<s<<endl;
```

```cpp
#include <iostream>
#include <cstring> // # include<cstring>
using namespace std;

int main()
{
    string s;
    getline(cin, s);     //得到输入的一行并且将其当成字符串输入给S
    int len = s.length();
    for (int i = 0; i < len; i++)
    {
        if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' || s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')
        {
            s[i] = toupper(s[i]);//由小写改成大写
        }
        else
        {
            s[i] = tolower(s[i]);//由大写改成小写
        }
    }
    cout << s << endl;
    return 0;
}
```

```cpp
#include <iostream>
#include <cstring>
#include <unordered_map>
using namespace std;

unordered_map<char, int> count;  // 哈希表，记录每个字符的出现次数

void backtrack(string& s, int idx, int& res)
{
    if (idx == s.length())  // 已经填完了所有位置
    {
        res++;  // 记录一种排列
        return;
    }

    for (auto& c : count)  // 枚举所有可用的字符
    {
        if (c.second > 0)  // 当前字符还有剩余可用的
        {
            s[idx] = c.first;  // 填入当前字符
            c.second--;  // 将当前字符的出现次数减1
            backtrack(s, idx + 1, res);  // 继续递归填下一个位置
            c.second++;  // 将当前字符的出现次数加1，以便进行下一次尝试
        }
    }
}

int main()
{
    string s;
    cin >> s;

    for (auto c : s)  // 统计每个字符的出现次数
    {
        count[c]++;
    }

    int res = 0;
    backtrack(s, 0, res);
    cout << res << endl;

    return 0;
}
```

#### 8.15 动态规划股票买卖问题合集

需要使用三维度的动态规划算法来进行求解。

①只有一次交易的情况下

[121. 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/)

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size()==0) return 0;
        int cur_min = INT_MAX;// 维护一个记录前面最小值的变量
        int res_max = 0;
        for(int i=1;i<prices.size();i++){
            cur_min = min(cur_min,prices[i-1]);
            res_max = max(res_max,prices[i]-cur_min);
        }
        return res_max;
    }
};
```

②无数次交易的场景下

[122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

```cpp
class Solution {
public:
    //
    int maxProfit(vector<int>& prices) {
        if(prices.size()==0) return 0;
        // dp[i][0] 表示不持有股票,针对prices[0:i]所能得到的最大利润
        // dp[i][1] 表示持有股票,  针对prices[0:i]所能得到的最大利润
        vector<vector<int>> dp(prices.size(),vector<int>(2,0));
        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for(int i=1;i<prices.size();i++){
            dp[i][0]= max(dp[i-1][0],dp[i-1][1]+prices[i]);
            dp[i][1]= max(dp[i-1][1],dp[i-1][0]-prices[i]);
        }
        return dp[prices.size()-1][0];
    }
}; 
```

③只能进行两笔交易的情况下

[123. 买卖股票的最佳时机 III - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size()==0) return 0;
        vector<vector<int>> dp(prices.size(),vector<int>(5,0));
        // dp[i][0]  针对prices[0:i],不进行任何交易所能得到的最大利润
        // dp[i][1]  针对prices[0:1],处于第一次买入的状态所能得到的最大利润
        // dp[i][2]  针对prices[0:i],处于第一次卖出的状态所能得到的最大利润
        // dp[i][3]  针对prices[0:i],处于第二次买入的状态所能得到最大利润
        // dp[i][4]  针对prices[0:1],处于第二次卖出的状态所能得到的最大的利润
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;
        for(int i=1;i<prices.size();i++){
            dp[i][1] = std::max(dp[i-1][0]-prices[i],dp[i-1][1]);
            dp[i][2] = std::max(dp[i-1][2],dp[i-1][1]+prices[i]);
            dp[i][3] = std::max(dp[i-1][2]-prices[i],dp[i-1][3]);
            dp[i][4] = std::max(dp[i-1][3]+prices[i],dp[i-1][4]);
        }

        vector<int> ans = dp[prices.size()-1];
        return *max_element(ans.begin(),ans.end());
    }
};
```



④买卖股票的最佳时期

表示不对交易次数k进行限制。

[188. 买卖股票的最佳时机 IV - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)

```cpp
// dp[i][j]表示第i天的状态为j
// j=0 表示不进行任何交易
// j=1 表示当天的状态为进行完第一次买入
// j=2 表示当天的状态为进行完死一次卖出
//...
// j=2*k-1表示进行完第k次买入(奇数表示买入)
// j=2*k  表示进行完第k次卖出(偶数表示卖出)

// dp[0][0] = 0           // j为0的时候的初始值是知晓的
// dp[0][1] = -prices[0] 第0天做买入操作
// dp[0][2] = 0          可以理解为当天买入当天卖出
// dp[0][3] = -prices[0] 理解为第0天买入，第0天卖出，再进行第0天第二次交易的操作 
// dp[0][4] = 0           //第2次卖出也表示为0
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        if(prices.size()==0) return 0;
        vector<vector<int>> dp(prices.size(),vector<int>(2*k+1,0));// 所有的i为0的状态全部进行了赋值操作
        for(int j=1;j<=2*k;j+=2){
            dp[0][j] = -prices[0];// 第0天的买入卖出都和第0天相关
        }
        for(int i=1;i<prices.size();i++){
            for(int j=0;j<2*k-1;j+=2){
                // 奇数表示买入的状态
                dp[i][j+1] = max(dp[i-1][j+1],dp[i-1][j]-prices[i]);
                // 偶数表示卖出的状态
                dp[i][j+2] = max(dp[i-1][j+2],dp[i-1][j+1]+prices[i]);
            }
        }
        return dp[prices.size()-1][2*k];        
        // 并没有一定要将k种状态都用完。
        //vector<int> v = dp[prices.size()-1];
        //return *max_element(v.begin(),v.end());
    }
};
```

⑤买卖股票的最佳时期(含有冷冻期)

[309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size()==0) return 0;
        vector<vector<int>> dp(prices.size(),vector<int>(4,0));
        // dp[i][0] 持有股票
        // dp[i][1] 不持有股票：之前卖出股票，今天不是冷冻期
        // dp[i][2] 不持有股票：今天卖出股票，
        // dp[i][3] 不持有股票：今天为冷冻期状态，单冷冻期不可持续，只有一天
        dp[0][0] = -prices[0];
        for(int i=1;i<prices.size();i++){
            // ①昨天持有 ② 昨天无，今天买 ③昨天为冷冻期
            dp[i][0] = max(dp[i-1][0],max(dp[i-1][1]-prices[i],dp[i-1][3]-prices[i]));
            // ①昨天就不持有 ②今天刚卖 
            dp[i][1] = max(dp[i-1][1], dp[i-1][3]);
            // 昨天持有今天卖出
            dp[i][2] = dp[i-1][0]+prices[i];
            // 
            dp[i][3] = dp[i-1][2]; 
        }

        vector<int> res = dp[prices.size()-1];
        return *max_element(res.begin(),res.end());
    }
};
```

**方法二**

```cpp
// 相比于前面，这里用的是三维度的状态机
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.empty()) {
            return 0;
        }
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(3,0));
        dp[0][0] = -prices[0];
        // f[i][0]: 手上持有股票的最大收益
        // f[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益
        // f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益
        for(int i =1;i<n;i++){
            dp[i][0] = max(dp[i-1][0],dp[i-1][2]-prices[i]);// 今天买的话昨天就不处于冷冻期
            dp[i][1] = dp[i-1][0]+prices[i];
            dp[i][2] = max(dp[i-1][2],dp[i-1][1]);
        }
        return max(dp[n-1][1],dp[n-1][2]);
    }
};
```

⑥含有手续费的情况下

和第二题一模一样，唯一的区别就是减去了一个值。



[714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        if(prices.size()==0) return 0;
        vector<vector<int>> dp(prices.size(),vector<int>(2,0));
        // dp[i][0]不持有股票
        // dp[i][1]持有股票
        dp[0][0]=0;
        dp[0][1]= -prices[0]-fee;
        for(int i=1;i<prices.size();i++){
            // 昨天就不持有 或者 昨天持有但是今天卖掉了
            dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i]);
            // 
            dp[i][1] = max(dp[i-1][1],dp[i-1][0]-prices[i]-fee);
        }

        return max(dp[prices.size()-1][0],dp[prices.size()-1][1]);
    }
};
```

#### 8.16 动态规划打家劫舍问题合集

[198. 打家劫舍 - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber/description/)

```cpp
// 利用了类似于上面的股票买卖问题
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()==0) return 0;
        vector<vector<int>> dp(nums.size(),vector<int>(2,0));
        // dp[i][0]不抢
        // dp[i][1]抢
        dp[0][0] = 0;
        dp[0][1] = nums[0];

        for(int i=1;i<nums.size();i++){
            dp[i][0] = max(dp[i-1][0],dp[i-1][1]);
            dp[i][1] = dp[i-1][0]+nums[i];
        }
        return max(dp[nums.size()-1][0],dp[nums.size()-1][1]);
    }
};
```

[213. 打家劫舍 II - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-ii/)



成环形的情况下

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()==0) return 0;
        if(nums.size()==1) return nums[0];
        vector<int> nums1(nums.begin(),nums.end()-1);
        vector<int> nums2(nums.begin()+1,nums.end());
        return max(rob_one(nums1),rob_one(nums2));
    }
    // 这个函数完全就是第一个函数具有的
    int rob_one(vector<int>& nums){
        if(nums.size()==0) return 0;
        vector<vector<int>> dp(nums.size(),vector<int>(2,0));
        dp[0][0] = 0;
        dp[0][1] = nums[0];
        for(int i=1;i<nums.size();i++){
            dp[i][0] = max(dp[i-1][0],dp[i-1][1]);
            dp[i][1] = dp[i-1][0]+nums[i];
        }
        return max(dp[nums.size()-1][0],dp[nums.size()-1][1]);
    }
};
```

[337. 打家劫舍 III - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-iii/)

站在二叉树上进行打劫。要记住这个树型dp中比较关键点

```cpp
class Solution {
public:
    // 输入的是二叉树的根节点
    int rob(TreeNode* root) {
        if(root==nullptr) return 0;
        vector<int> res = trance(root);
        return max(res[0],res[1]);
    }
    // dp是一个二维度的数组
    // dp[0] 表示不偷取当前节点
    // dp[1] 表示偷取当前节点
    vector<int> trance(TreeNode* cur){
        if(cur==nullptr) return {0,0};
        vector<int> left = trance(cur->left);
        vector<int> right = trance(cur->right);

        // 不偷当前节点，则可以选择子节点偷或者不偷
        int res_0 = max(left[0],left[1])+max(right[0],right[1]);
        // 偷取当前节点，子节点就不能偷取
        int res_1 = left[0]+right[0]+cur->val;
        return {res_0,res_1};
    }
}; 
```

### 9、递归与回溯算法

```python
from collections import deque


# 存储二叉树节点的类
class Node:
    def __init__(self, data, left=None, right=None):
        self.data = data
        self.left = left
        self.right = right


# 检查给定节点是否为叶节点的函数
def isLeaf(node):
    return node.left is None and node.right is None


all_way = []

# 递归的函数查找从根节点到每个叶节点的路径
def printRootToLeafPaths(node, path):
    # 基础案例
    if node is None:
        return

    # 包含当前节点的路径
    path.append(node.data)

    # 如果找到叶节点，打印路径
    if isLeaf(node):
        all_way.append(list(path))

    # 递归左右子树
    printRootToLeafPaths(node.left, path)
    printRootToLeafPaths(node.right, path)

    # 回溯：左后删除当前节点，右子树完成，一定要回溯，否则输出结果是存在问题的
    path.pop()


# 打印从根节点到每个叶子节点的路径的主要功能
def printRootToLeafPath(root):
    # 列表存储根到叶路径
    path = deque()
    printRootToLeafPaths(root, path)  # 输入的是一个跟节点和一个空的deque
    print("nihao")


if __name__ == '__main__':
    ''' Construct the following tree
              1
            /   \
           /     \
          2       3
         / \     / \
        4   5   6   7
               /     \
              8       9
    '''

    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)
    root.right.left = Node(6)
    root.right.right = Node(7)
    root.right.left.left = Node(8)
    root.right.right.right = Node(9)

    # 打印所有从根到叶的路径
    printRootToLeafPath(root)
    print(all_way)
```



### 11、二叉树

二叉树的数据结构如下：

```cpp
struct TreeNode {
     int val;
     TreeNode *left;
     TreeNode *right;
     TreeNode() : val(0), left(nullptr), right(nullptr) {}
     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 };

```

二叉树的遍历

前序遍历

```cpp
// 1.递归版本的前序遍历
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        std::vector<int> res;
        transback(root,res);
        return res;
    }
	// 核心代码
    void transback(TreeNode* root,vector<int> &res){
        if(root==nullptr) return;
        res.push_back(root->val);
        transback(root->left,res);
        transback(root->right,res);
    }
};

// 2.迭代版本的前序遍历。
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;// 空指针返回空结果，很正确。
        st.push(root);                  // 将当前节点加入到栈空间中
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            result.push_back(node->val);
            // 首先添加右边再添加左边。
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return result;
    }
};
```

中序遍历

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> v;
        trance(root,v);
        return v;
    }

    void trance(TreeNode* root, vector<int> &v){
        if(root==nullptr) return;
        trance(root->left,v);
        v.push_back(root->val);
        trance(root->right,v);
    }    
};


// 迭代版本的中序遍历
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```

后序遍历

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> v;
        trance(root,v);
        return v;
    }

    void trance(TreeNode* root, vector<int> &v){
        if(root==nullptr) return;
        trance(root->left,v);
        trance(root->right,v);
        v.push_back(root->val);
    }
};

// 2、迭代版本的后序遍历
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
};
```

二叉树的层序遍历(从上到下，从左到右)

<img src="./asserts/1.jpg" style="zoom:50%;" />





[102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

返回节点值的层序遍历结果

```cpp
// 其实是利用了BFS的思想(也就是广度优先算法)
void levelTraverse(TreeNode* root) {
    if(root==nullptr) return;
    queue<TreeNode*> q;
    TreeNode* node;
    q.push(root);
    while(!q.empty()){
        int s = q.size();
        for(int i = 0;i<s;i++){
            node = q.front();//返回队列中第一个元素
            q.pop();//移除第一个元素
            // 此位置为遍历某一层的元素
            if(node->left!=nullptr) q.push(node->left);
            if(node->right!=nullptr) q.push(node->right);
        }
    }
}

```

#### 11.1 leetcode104求二叉树的最大深度

针对二叉树的题目，一般有两种求解方法，第一种是使用遍历的方法，另外一种是类似于动态规划，使用分解问题的方法。

针对求解二叉树的最大深度

①使用遍历的方法

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr) return 0;//如果输入的为空节点，则最大深度肯定为0
        int max_dep = 0;
        int curr_dep = 0;
        trance(root, curr_dep,max_dep);// 递归函数
        return max_dep;
    }

    void trance(TreeNode* root, int& depth, int& max_dep){
        if(root==nullptr) return;// 递归的终止条件
        depth++;
        max_dep = std::max(depth,max_dep);
        trance(root->left,depth,max_dep);
        trance(root->right,depth,max_dep);
        depth--;                // 这里有点类似于回溯算法
    }
};
```

②使用分解问题的方法

类似于动态规划，将问题进行详细的分解计算。

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        int res =get_maxdepth(root);
        return res;
    }
    int get_maxdepth(TreeNode* root){//该迭代函数直接返回了相关的计算的值的信息
        if(root==nullptr) return 0;
        int max_left = get_maxdepth(root->left);
        int max_right = get_maxdepth(root->right);
        int max_depth = std::max(max_left, max_right)+1;//  左边和右边中出现的最大点一个
        return max_depth;
    }
};
```

#### 11.2 leetcode504求二叉树的最大直径

也就是两个节点之间的最大距离。

这里利用到了后序遍历的结果。

```cpp
class Solution {
public:
    int max_depth = 0;
    int diameterOfBinaryTree(TreeNode* root) {
        max_tdepth(root);
        return max_depth;
    }
    int max_tdepth(TreeNode* root){
        if(root==nullptr) return 0;//空指针，返回0
        int left_depth=max_tdepth(root->left);
        int right_depth=max_tdepth(root->right);
        max_depth = std::max(max_depth,left_depth+right_depth); // 更新全局变量
        return std::max(left_depth,right_depth)+1;              // 更新本次运行结果
    }
};
```

#### 11.3 翻转二叉树

①方法1：通过遍历的方法翻转二叉树

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        tranceback(root);
        return root;    //返回本身
    }

    void tranceback(TreeNode* root){
        if(root==nullptr) return;
        tranceback(root->left);
        tranceback(root->right);
        TreeNode* temp = root->left;
        root->left=root->right;
        root->right = temp;
    }
};
```

②通过翻转子问题的方法来翻转二叉树

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        return inverse(root);
    }

    // 输入一个节点，对该节点进行翻转
    TreeNode* inverse(TreeNode* root){
        if(root==nullptr) return root;//空指针不进行任何操作
        TreeNode* left_node = inverse(root->left);
        TreeNode* right_node = inverse(root->right);
        root->left = right_node;
        root->right = left_node;
        return root;
     }
};
```

#### 11.4 填充每一个节点的右侧节点指针

方法1：通过层序遍历来进行操作

通过层序遍历的思想是更加容易理解的。

```cpp
class Solution {
public:
    Node* connect(Node* root) {
        if(root==nullptr) return root;
        queue<Node*> q;
        q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i=0;i<size;i++){
                Node * curr_node = q.front();//需要将当前节点的值指向下一个节点
                q.pop();
                if((i+1)==size)
                {
                    curr_node->next = nullptr;
                }
                else
                {
                     curr_node->next = q.front();
                }
                if(curr_node->left!=nullptr) q.push(curr_node->left);
                if(curr_node->right!=nullptr) q.push(curr_node->right);
            }
        }
        return root;
    }
};
```

方法2：通过遍历三叉树的方式来求解

```cpp
// 主函数
Node* connect(Node* root) {
    if (root == nullptr) return nullptr;
    // 遍历「三叉树」，连接相邻节点
    traverse(root->left, root->right);
    return root;
}

// 三叉树遍历框架
void traverse(Node* node1, Node* node2) {
    if (node1 == nullptr || node2 == nullptr) {
        return;
    }
    /**** 前序位置 ****/
    // 将传入的两个节点穿起来
    node1->next = node2;
    
    // 连接相同父节点的两个子节点
    traverse(node1->left, node1->right);
    traverse(node2->left, node2->right);
    // 连接跨越父节点的两个子节点
    traverse(node1->right, node2->left);
}
```

#### 11.5 将二叉树原地展开为链表



方法一：通过二叉树遍历的方式进行求解

方法二：分解为两个子问题

```cpp
class Solution {
public:
    void flatten(TreeNode* root) {
        trance(root);
    }
    TreeNode* trance(TreeNode* root){
        if(root==nullptr) return nullptr;
        TreeNode* left = trance(root->left);
        TreeNode* right = trance(root->right);
        if(left==nullptr){  //需要考虑左指针为空这种情况
            root->right = right;
        }
        else{
            root->right = left;
            root->left = nullptr;
            while((left->right)!=nullptr)
            {
                left = left->right;
            }
            left->right = right;
        }
        return root;
    }
};
```



#### 11.6 (构造)最大二叉树

一般情况下，构造类型的问题都需要利用的是分解子问题，而不是二叉树的构造。

```cpp
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        if(nums.size()==0) return nullptr;
        TreeNode* root = trance(nums);
        return root;
    }
    TreeNode* trance(vector<int>& nums){
        if(nums.size()==0) return nullptr;
        auto it = std::max_element(nums.begin(),nums.end());// 最大值所在的迭代器
        int index = std::distance(nums.begin(),it);         //最大值所在的索引
        TreeNode* root = new TreeNode(nums[index]);         //以最大值为根节点创建一个二叉树根节点

        vector<int> left(nums.begin(),it);
        TreeNode* left_tree = trance(left);

        vector<int> right(it+1,nums.end());
        TreeNode* right_tree = trance(right);

        root->left = left_tree;
        root->right = right_tree;
        return root;
    }
};
```

#### 11.7 (构造)从前序和中序遍历构造二叉树

<img src="./asserts/007.png" style="zoom:50%;" />

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {//根据输入的节点返回二叉树
        if(preorder.size()==0||inorder.size()==0) return nullptr;
        TreeNode* root = trance(preorder,inorder);
        return root;
    }
    TreeNode* trance(vector<int>& preorder, vector<int>& inorder){
        if(preorder.size()==0||inorder.size()==0) return nullptr;
        TreeNode* root= new TreeNode(preorder.front());//根节点

        auto it = std::find(inorder.begin(),inorder.end(),preorder.front());// 头结点在中序遍历中的迭代器
        int left_size = std::distance(inorder.begin(),it);//左树尺寸
        int right_size = std::distance(it,inorder.end())-1;//右树尺寸

        vector<int> left_preorder(preorder.begin()+1,preorder.begin()+left_size+1);
        vector<int> right_preorder(preorder.begin()+left_size+1,preorder.end());
        vector<int> left_inorder(inorder.begin(),it);
        vector<int> right_inorder(it+1,inorder.end());

        TreeNode* left_node = trance(left_preorder,left_inorder);
        TreeNode* right_node = trance(right_preorder,right_inorder);

        root->left = left_node;
        root->right = right_node;
        return root;
    }
};
```

#### 11.8 (构造)从后序和中序遍历构造二叉树

<img src="./asserts/5.jpg" style="zoom:50%;" />

```cpp
```



#### 11.10 寻找重复的字树

这个是非常重点的题目

https://leetcode.cn/problems/find-duplicate-subtrees/

这里采用的方法是后序遍历的序列化与反序列化。

```cpp
class Solution {
public:
    // 1.先将数组给序列化，保存在容器中，并且记录序列化后的字符串最终出现的次数
    // 2.通过后续遍历，一边遍历，一边记录
    std::unordered_map<std::string, int> memo;//用于记录每一个字符串出现的次数
    std::vector<TreeNode*> res;               //返回值，用于记录所有的返回值的结果
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
          traverse(root);
          return res;
    }
    std::string traverse(TreeNode* root) {
        if (root == nullptr) {
            return "#";
        }
        std::string left_str = traverse(root->left);
        std::string right_str = traverse(root->right);
        std::string curr_str = left_str + "," + right_str + "," + std::to_string(root->val);
        if (memo.find(curr_str) != memo.end()) {
            memo[curr_str] += 1;
            if (memo[curr_str] == 2) { // 只有第二次出现时才添加到结果中
                res.push_back(root);  
            }
        } else {
            memo[curr_str] = 1;
        }
        
        return curr_str;
    }
};
```

#### 11.11 二叉树的序列化

① 前序遍历的序列化与反序列化

<img src="./asserts/640.jpg" style="zoom:50%;" />



```cpp
class Codec {
public:

    // C++中前序遍历代码
    string serialize(TreeNode* root) {
        std::string sb;
        if(root==nullptr) return sb;
        
        ser_trance(root,sb);// 将最后的逗号去除掉
        sb.pop_back();
        return sb;
    }
    
    // 前序遍历的核心代码
    void ser_trance(TreeNode* root,std::string &sb){
        if(root==nullptr){
            sb = sb+"null"+",";
            return;}
        sb = (sb+std::to_string(root->val)+",");
        ser_trance(root->left,sb);
        ser_trance(root->right,sb);
    }
    // 1,2,null,4,null,null,3,null,null
    
    // 可以理解为python中的.split函数
    std::queue<std::string> split(std::string &str) {
        std::queue<std::string> vec;
        if (str.empty()) return vec;
        int pre = 0;
        for (int i = 0; i <= str.size(); i++) {
            if (str[i] == ','||i==str.size()) {
            vec.push(str.substr(pre, i - pre));
            pre = i + 1;
         }
        }
        return vec;
    }
    
    // 一定是
    TreeNode* dec_trance(std::queue<std::string> &v_data){
        string first = v_data.front();
        v_data.pop();
        if(first=="null") return nullptr;
        TreeNode* root = new TreeNode(std::stoi(first));// 将字符转换为数字
        root->left = dec_trance(v_data);
        root->right = dec_trance(v_data);
        return root;
    }
    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if(data.size()==0) return nullptr;           //"1,2,#,4,#,#,3,#,#"
        std::queue<std::string> v_data = split(data);//保存所有数据的链表
        return dec_trance(v_data);
    }
};
```



②后序遍历的序列化与反序列化

<img src="./asserts/22.jpg" style="zoom:50%;" />

```cpp
// 1、递归方式序列化
void ser_trance(treenode* root, std::string& sb) {
    if (root == nullptr) {
        sb = sb + "null" + ",";
        return;
    }
    ser_trance(root->left, sb);
    ser_trance(root->right, sb);
    sb = (sb + std::to_string(root->val)+",");
}

std::string serialize(treenode* root) {
    std::string sb;
    if (root == nullptr) return sb;
    ser_trance(root, sb);
    sb.pop_back();    //  属于去掉最后一个逗号
    return sb;
}


// 2、分解子问题
std::string trance2(TreeNode* root) {
    if (root == nullptr) return "null";
    std::string left_str = trance2(root->left);
    std::string right_str = trance2(root->right);
    return left_str + "," + right_str + "," + std::to_string(root->val);
}
std::string serialize(TreeNode* root) {
    if (root == nullptr) return "null";//空节点序列化，返回空字符串
    std::string str = trance2(root);
    return str;
}
```

下面是是进行反序列化的代码

```cpp
    std::vector<std::string> split(std::string &str) {
        std::vector<std::string> vec;
        if (str.empty()) return vec;
        int pre = 0;
        for (int i = 0; i <= str.size(); i++) {
            if (str[i] == ','||i==str.size()) {
            vec.push_back(str.substr(pre, i - pre));
            pre = i + 1;
         }
        }
        return vec;
    }
    TreeNode* dec_trance(std::vector<std::string> &v_data){
        if(v_data.empty()) return nullptr;
        std::string last =  v_data.back();
        if(last=="null") return nullptr;
        TreeNode* root = new TreeNode(std::stoi(last));
        root->right = dec_trance(v_data);
        root->left = dec_trance(v_data);
        return root;
    }
    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if(data.size()==0) return nullptr;
        std::vector<std::string> vec= split(data);
        return dec_trance(vec);
    }
```

③层序遍历的序列化与反序列化

<img src="./asserts/23.jpg" style="zoom:50%;" />



```cpp
std::string trance(TreeNode* root) {
    if (root == nullptr) return "null,";
    std::string str;
    std::queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            TreeNode* node = q.front();
            q.pop();
            if (node == nullptr) {
                str =(str+ "null"+",");
                continue;
            }
            else{
                str = (str + std::to_string(node->val)+",");
            }
            q.push(node->left);
            q.push(node->right);
        }
    }
    return str;
 }

std::string serialize(TreeNode* root) {
    if (root == nullptr) return "null";//空节点序列化，返回空字符串
    std::string str = trance(root);
    str.pop_back();
    return str;
}
```



#### 11.12 路径总和(区分根节点和子节点)

[112. 路径总和 - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum/description/)

判断二叉树从根节点到叶子节点总和等于某值的子路是否存在

```cpp
class Solution {
public:
    int value = 0;
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root==nullptr) return false;
        int sum = 0;
        trance(root,sum,targetSum);
        if(value==0){
            return false;
        }
        else{
            return true;
        }
    }

    void trance(TreeNode* root, int sum, int targetSum){
        if(root==nullptr){//为叶子节点的情况下
            return;
        }
        sum+=root->val;
        if(root->left==nullptr&&root->right==nullptr){
            if(sum==targetSum){
                value+=1;
            }
        }
        trance(root->left,sum,targetSum);
        trance(root->right,sum,targetSum);
    }
};
```

下面是方法二：是更加简单的方法

```cpp
class Solution {
public:
    int res = 0;
    bool hasPathSum(TreeNode* root, int targetSum) {
        trance(root,targetSum);
        if(res==0){
            return false;
        }
        else{
            return true;
        }
    }

    // 以该节点为根节点，往下延伸的子路的长度是多少
    void trance(TreeNode* root, int target){
        if(root==nullptr) return;
        if(root->left==nullptr&&root->right==nullptr&&root->val==target){
            res++;
        }
        trance(root->left,target-root->val);   // 需要减去相应的值
        trance(root->right,target-root->val);  // 需要减去相应的值
    }
};
```

#### 11.13 路径总和(不区分根节点和子节点)

[437. 路径总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-iii/description/)

采用双层递归的方法进行求解(针对每一层递归，再采用一次递归进行求解)

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

```cpp
class Solution {
public:
    // 相当于每进入一个节点，都要计算以该节点，该节点左、右节点分别为根节点进行计算
    // 1.root为根节点的targetSum字树个数（需要递归求解）
    // 2.root左节点为根节点targetSum的子树个数
    // 3.root右节点为根节点targetSum的字树个数
    long pathSum(TreeNode* root, long targetSum) {      // 这里是主函数(主函数)
        if(root==nullptr) return 0;
        long ret = 0;
        long root_sum = rootsum(root, targetSum);        // 以该节点作为根节点
        long left_sum = pathSum(root->left,targetSum);   // 2.以该节点左节点
        long right_sum = pathSum(root->right,targetSum); // 3.以 该节点右节点
        return root_sum+left_sum+right_sum;
    }

    // 1.计算以该节点为根节点，targetSum子树个数（分解子问题的方法）
    long rootsum(TreeNode* root, long targetSum){// 类似于11.13的求解步骤
        if(root==nullptr) return 0;
        long ret =0;
        if(root->val==targetSum) ret++;
        long left_num = rootsum(root->left,targetSum-root->val);
        long right_num = rootsum(root->right,targetSum-root->val);
        return ret+left_num+right_num;
    }
};
```

### 12、二叉搜索树

二叉搜索树的中序遍历是有序的。

#### 12.1 二叉搜索树中第k小的元素

**直接利用中序遍历，可以获得有序的结果。**

```cpp
class Solution {
public:
    int res;
    int kthSmallest(TreeNode* root, int k) {
        if(root==nullptr) return 0;
        int index = 0;
        trance(root,index,k);
        return res;
    }

    void trance(TreeNode* root,int& index, int k){
        if(root==nullptr) return;
        trance(root->left,index, k);
        index++;
        if(index==k) res = root->val;
        trance(root->right,index, k);
    }
};
```

#### 12.2 二叉搜索树转换为累加树

修改了递归的顺序（先从右边开始再从左边开始）

[538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-bst-to-greater-tree/description/)

和前面遍历不同，先遍历右边，再遍历左边。

```cpp
class Solution {
public:
    TreeNode* convertBST(TreeNode* root) {
        if(root==nullptr) return nullptr;// 返回转换之后的累加树的根节点
        int sum=0;
        trance(root,sum);
        return root;
    }
    void trance(TreeNode* root, int& sum){
        if(root==nullptr) return;
        trance(root->right,sum);
        sum+=root->val;
        root->val =sum;
        trance(root->left,sum);
    }
};
```

#### 12.3 判断二叉搜索树的合法性

判断是否满足标准的二叉搜索树

```cpp
class Solution {
public:
    bool flag = true;// 搜索到目前为止的最大值
    long long ref_max =(long long)INT_MIN-1;//相对最大的值
    bool isValidBST(TreeNode* root) {
        if(root==nullptr) return false;
        trance(root);
        return flag;}
    void trance(TreeNode* root){
        if(root==nullptr) return;
        trance(root->left);
        if(ref_max>=root->val) flag = false;
        ref_max =root->val;
        trance(root->right);
    }
};

```

通过前序遍历。

下面这种是比较标准的方法

前序遍历的时候更新上下边界，后序遍历的时候进行判断。

1.刚进入某一个节点时判断该节点是否合法

2.递归地判断该节点的左右节点是否是合法的

```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return trance(root, LONG_MIN, LONG_MAX);
    }
    // 前序遍历的时候更新节点边界，后序遍历判断结果。
    bool trance(TreeNode* root, long long lower, long long high){
        if(root==nullptr) return true;      //为空的话肯定是合法的二叉搜索树
        if(root->val<=lower||root->val>=high) return false;// 不能等于，等于也是错误的。
        bool left = trance(root->left,lower, root->val);
        bool right = trance(root->right,root->val, high);
        return left&&right;
    }
};
```

#### 12.4 二叉树的基本操作

二叉树的基本操作框架

```cpp
// 相比于前面增加了判断
void BST(TreeNode root, int target) {
    if (root.val == target)
        // 找到目标，做点什么
    if (root.val < target) 
        BST(root.right, target);
    if (root.val > target)
        BST(root.left, target);
}
```

① 查找

[700. 二叉搜索树中的搜索 - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-a-binary-search-tree/description/)

返回根值为val的子树

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(root==nullptr) return nullptr;
        if(root->val<val) return searchBST(root->right,val);
        if(root->val>val) return searchBST(root->left,val);
        return root;      // 上面三项都不满足的话说明恰好是相等的
    }
};
```

② 插入

往二叉搜索树中插入一个数，二叉搜索树，总是存在一个不需要调整树结构就能插入新节点的方法。

```cpp
// 往二叉搜索树中添加某值
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root==nullptr) return new TreeNode(val);
        if(root->val>val) root->left = insertIntoBST(root->left, val);
        if(root->val<val) root->right = insertIntoBST(root->right, val);
        return root;
    }
};
```

③删除

- a. 要删除的结点无孩子结点（也就是叶子结点）
- b. 要删除的结点只有左孩子结点
- c. 要删除的结点只有右孩子结点
- d. 要删除的结点有左、右孩子结点（这种情况最为复杂）

需要找到左子树最大的节点或者右子树最小的节点来接替自己。

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root==nullptr) return root;
        if(root->val==key)
        {
            // 1.根节点
            if(root->left==nullptr&&root->right==nullptr) return nullptr;
            // 2.存在左或者右节点中的一个
            if(root->left==nullptr) return root->right;
            if(root->right==nullptr) return root->left;
            // 3.左边右边都存在(找到右边的最小值提过来)
            TreeNode* min = find_min(root->right);
            root->val = min->val;
            root->right = deleteNode(root->right,min->val);
            return root;
        }
        if(root->val<key) root->right=deleteNode(root->right,key);
        if(root->val>key) root->left=deleteNode(root->left,key);
        return root;
    }
    // 寻找最小值(二叉搜索树中的最小值)
    TreeNode* find_min(TreeNode* root){
        if(root->left!=nullptr) return find_min(root->left);
        return root;
    }
};

// 寻找二叉搜索树中的最小值也可以采用这种方法
TreeNode * find_min(TreeNode* root){
    if(root->left==nullptr) return root;
    return find_min(root->left);
}
```

#### 12.5 不同的二叉搜索树个数

https://leetcode.cn/problems/unique-binary-search-trees/description/

①使用动态规划的方法求解。

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> v(n+1,0);// 动态规划的dp数组,表示为n的时候二叉搜索树的个数
        v[0] =1;
        v[1] =1;
        for(int i=2;i<=n;i++){// 从2开始进行(因为1已经确定了，所以还存在很大问题
            for(int j=1;j<=i;j++){
                int left_num = v[j-1];
                int right_num = v[i-j];
                v[i]+=left_num*right_num;
            }
        }
        return v[n];
    }
};
```

②使用递归的方法求解

使用递归其实也使用到了dp数组。使用数组来记录重复子问题的解才更加方便。

```cpp
class Solution {
public:
    int numTrees(int n) {
        std::vector<int> v(n+1,0);
        v[0]=1;
        v[1]=1;//也是用到了dp数组
        int res= cal(n,v);
        return res;
    }
    int cal(int n, vector<int> &v){
        if(n==0) return 1;      //根节点恰好为n或者为1的情况下，这种情况下，自然只有一种使用方法的。
        if(v[n]!=0) return v[n];// 如果dp数组中已经保存了该数据，则直接使用已有值即可。
        int sum =0;
        for(int i=1;i<=n;i++){ // 
            int left = cal(i-1,v);  // 左边元素个数就为i-1
            int right = cal(n-i,v); // 右边元素个数就为n-i
            sum+=left*right;
        }
        v[n] = sum;
        return sum;
    }
};
```

③另外一种递归的方法

通过一个数组进行递归。

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1,0);
        dp[0] =1; //没有任何数，那就是空指针
        dp[1] =1; //只有一个元素，那也是只有一种方法，
        int res = cal(1,n,dp);// 1到n元素包含多少个
        return res;
    }
    int cal(int lower,int high, vector<int> &dp){
        if(lower==high) return 1;
        if(lower>high) return 1;
        if(dp[high-lower+1]!=0) return dp[high-lower+1];
        int sum = 0;
        for(int i=lower;i<=high;i++){// 以其中的每一个点作为根节点
            int left = cal(lower, i-1, dp);
            int right = cal(i+1,high, dp);
            sum+=left*right;
        }
        dp[high-lower+1] = sum; 
        return sum;
    }
};
```

#### 12.6 不同的二叉搜索树(同时需要保存树的答案) 这里是易错题(容易忘记)

https://leetcode.cn/problems/unique-binary-search-trees-ii/

```cpp
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        vector<TreeNode*> res = build(1, n);
        return res;
    }
    // 针对每一个范围该用什么方法
    vector<TreeNode*> build(int lower, int high){
        if(lower>high) return {nullptr};// 这里
        vector<TreeNode*> res;
        for(int i=lower;i<=high;i++){// 注意这个地方是小于等于某个值(以i节点建造的字树个数)
            vector<TreeNode*> left = build(lower,i-1); // 都是小于某个值
            vector<TreeNode*> right = build(i+1,high); // 都是大于某个值
            for(auto e_left:left){
                for(auto e_right:right){
                    TreeNode* root = new TreeNode(i);
                    root->left = e_left;
                    root->right = e_right;
                    res.push_back(root);
                }
            }
        }
        return res;
    }
};
```

#### 12.7 二叉搜索树的最大键值和

判断二叉树中最大的二叉搜索子树之和。

https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/

方法①：递归中嵌入递归函数(这里是复杂度较大的求解方式)

```cpp
class Solution {
public:
    int max_key_value=0;
    int maxSumBST(TreeNode* root) {
        trance(root);
        return max_key_value;
    }

    int trance(TreeNode* root){
        if(root==nullptr) return 0;
        int left = trance(root->left);
        int right = trance(root->right);
        if(valid(root, INT_MIN, INT_MAX)){
            max_key_value = std::max(max_key_value, left+right+root->val);
        }
        return root->val+left+right;
    }
	
    // 判断某二叉树是否是有效的二叉搜索树的函数(每一次都需要重新进行判断，复杂度较高)
    bool valid(TreeNode* root, int lower, int high){
        if(root==nullptr) return true;
        if(root->val<=lower||root->val>=high) return false;
        bool left = valid(root->left, lower, root->val);
        bool right = valid(root->right, root->val, high);
        return left&&right;// 都为true的时候才说明是合法的二叉树。
    }
};
```

方法②：

自定义复杂的返回结构体。

```cpp
class Solution {
public:
    int res;
    // 定义每一个回合的返回值是一个结构体
    struct SubTree {
        bool isBST;
        int minValue;
        int maxValue;
        int sumValue;
        SubTree(bool isBST, int minValue, int maxValue, int sumValue) : isBST(isBST), minValue(minValue), maxValue(maxValue), sumValue(sumValue) {}
    };

    SubTree dfs(TreeNode* root) {
        if (root == nullptr) {
            return SubTree(true, INT_MAX, INT_MIN, 0);
        }
        auto left = dfs(root->left);
        auto right = dfs(root->right);
        // 采用二叉树后序遍历的方式进行相关操作

        if (left.isBST && right.isBST &&
                root->val > left.maxValue && 
                root->val < right.minValue) {
            int sum = root->val + left.sumValue + right.sumValue;
            res = max(res, sum);
            return SubTree(true, min(left.minValue, root->val), 
                           max(root->val, right.maxValue), sum);
        } else {
            return SubTree(false, 0, 0, 0);
        }
    }

    int maxSumBST(TreeNode* root) {
        res = 0;
        dfs(root);
        return res;
    }
};
```

### 13、回溯算法

回溯顺序就是一个多叉树的遍历问题，并在在前序位置和后序位置做一些操作。

```cpp
// 回溯算就是一个n叉树的遍历问题，可以从
for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表
```

易错点①：递归结束的判断

回溯算法主要用于解决排列、组合、子集问题。

组合问题和子集问题其实是同一个问题。排列问题其实是**完全遍历**。组合问题和子集问题并不是**完全遍历**。



<img src="./asserts/24.jpg" style="zoom:33%;" />



<img src="./asserts/25.jpg" style="zoom:33%;" />



回溯算法就是一个多叉树遍历的问题，在前序位置和后序位置做一些事情。

#### 13.1 全排列问题

==组合顺序影响==

[46. 全排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutations/description/)

找到不重复数组能够排列的最大个数以及对应的值。

关注顺序

```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> permute(vector<int>& nums) {
    vector<int> track;
    unordered_set<int> visit;
    backtrance(nums,track,visit);
    return res;
}
void backtrance(vector<int>& nums,vector<int> track,unordered_set<int> visit){
    if(track.size()==nums.size()){
        res.push_back(track);
	}
    for(int i=0;i<nums.size();i++){
        if(visit.count(nums[i])==1) continue;
        visit.insert(nums[i]);
        track.push_back(nums[i]);
        backtrance(nums,track,visit);
        visit.erase(nums[i]);
        track.pop_back();
    }
}
};
```



```cpp
在三维空间中，求射线(ray)与球体(sphere)的交点(intersection)
已知三维空间中一条射线的起始点(origin)和方向(direction)，射线上的点可以表示为:origin+t*direction (t>=0).已知三维空间中一个球的球心(center)和半径 (radius)。
```



#### 13.2 N皇后问题

[51. N 皇后 - 力扣（LeetCode）](https://leetcode.cn/problems/n-queens/)

可以看成是一个排列问题。

n个皇后

track可以代表当前的track

```cpp
class Solution {
public:
    vector<vector<string>> res;
    vector<vector<string>> solveNQueens(int n) {
        vector<string> board(n,string(n,'.'));    // 初始化一个没有放置任何皇后的棋盘
        backtrance(board, 0);// 这边是从0开始进行搜索的
        return res;
    }
    // row用于记录当前是第几行，也即是路径
    void backtrance(vector<string> &board,int row){
        if(row==board.size()) {
            res.push_back(board);//如果当前就是最后一行的话(并不需要减去1)
            return;
        }
        for(int i=0;i<board.size();i++){// 遍历每一列
            // 如果当前列添加是非法的话
            if(!isvalid(board,row,i)){
                continue;//结束当前这一列
            }
            board[row][i] = 'Q';//添加当前的皇后
            // 进入到下面的行
            backtrance(board, row+1);
            // 撤销当前的操作
            board[row][i] = '.';

        }
    }

   bool  isvalid(vector<string> &board, int row, int col){
        // 判断每一行是否是合法的棋盘
        int n = board.size();
        for(int i =0;i<row;i++){
            // 正上方
            if(board[i][col]=='Q'){
                return false;
            }
            //左上角
            if(col-row+i>=0){
                if(board[i][col-row+i]=='Q') return false;
            }
            // 右上角
            if(col+row-i<n){
                if(board[i][col+row-i]=='Q') return false;
            }
        }
        return true;
    }
};
```

#### 13.3 N皇后2

前面是较为复杂的一种方法。而普通的方法只需要求解出n的大小就好。



```cpp
class Solution {
public:
    int res=0;
    int totalNQueens(int n) {
        if(n==1) return 1;
        vector<vector<int>> board(n,vector<int>(n,0));// 0表示没有放置皇后
        backtrance(board,0);
        return res;
    }
    void backtrance(vector<vector<int>> board, int row){
        if(row==board.size()){
            res++;
            return;
        }
        for(int i=0;i<board[0].size();i++){
            if(!judge_is_valid(board,row,i)){
                continue;
            }
            board[row][i]=1;
            backtrance(board, row+1);
            board[row][i]=0;
        }
    }
    // 表明当期的棋盘是否时合法的
    // 合法返回true
    // 不合法返回false
    bool judge_is_valid(vector<vector<int>> &board, int row, int col){
        // 一列一类判断是否是合法的
        for(int i=0;i<row;i++){
            // 判断是否在当前的前方
            if(board[i][col]==1){
                return false;
            } 
            // 判断是否在左前方 
            if(col-row+i>=0){
                if(board[i][col-row+i]==1) return false;
            }
            // 判断是否在右前方
            if(col+row-i<board.size()){
                if(board[i][col+row-i]==1) return false;
            }
        }
        return true;
    }
};
```

#### 13.4 组合总和3

leetcode216

https://leetcode.cn/problems/combination-sum-iii/

==不考虑顺序==

找出所有相加之和为 `n` 的 `k` 个数的组合。

不关注顺序需要添加开始索引。

①并未进行减枝

```cpp
class Solution {
public:
    // 和为n的k个数字
    vector<vector<int>> res;
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<int> track;
        trance(track, k, n, 1, 0);
        return res;
    }
    //start_index是为了避免出现重复元素，每一次都重新进行
    void trance(vector<int> &track, int &k, int& n, int start_index, int sum){
        if(track.size()==k){
            // 总和相等才添加进去
            if(sum==n){
                res.push_back(track);
            }
            return;
        }
        for(int i=start_index;i<=9;i++){  
            // 如果该值已经被使用过了
            track.push_back(i);
            trance(track, k, n, i+1,sum+i);// 注意这里更新了开始索引
            track.pop_back();
        }

    }
};
```

②进行减枝

```cpp
class Solution {
public:
    // 和为n的k个数字
    vector<vector<int>> res;
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<int> track;
        trance(track, k, n, 1, 0);
        return res;
    }
    void trance(vector<int> &track, int &k, int& n, int start_index, int sum){
        if(sum>n){
            return;//减枝
        }
        if(track.size()==k){
            // 总和相等才添加进去
            if(sum==n) res.push_back(track);
            return;
        }
        for(int i=start_index;i<=9;i++){  
            // 如果该值已经被使用过了
            track.push_back(i);
            trance(track, k, n, i+1,sum+i);// 易错点就在开始索引这个地方
            track.pop_back();
        }

    }
};
```

#### 13.5 子集问题(元素无重不可复选)

==不考虑顺序==

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

[78. 子集 - 力扣（LeetCode）](https://leetcode.cn/problems/subsets/description/)

这是开始自己的思路，开始看起来还是比较复杂的

```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> subsets(vector<int>& nums) {
        get_subset(nums);
        return res;
    }
    void get_subset(vector<int>& nums){
        // 遍历每一个深度的值
        for(int k=0;k<=nums.size();k++){
            unordered_set<int> used;
            vector<int> track;
            back_trance(nums,k,track,used,0);
        }
    }
    // k是深度
    void back_trance(vector<int>& nums, int k, vector<int> track, unordered_set<int> used, int start_index){
        if(track.size()==k){
            res.push_back(track);
            return;
        }
        for(int i=start_index;i<nums.size();i++){
            if(used.find(nums[i])!=used.end()) continue;
            track.push_back(nums[i]);
            used.insert(nums[i]);
            back_trance(nums, k, track, used, i+1);
            track.pop_back();
            used.erase(nums[i]);
        }
    }
};
```

求解方式2

第二种求解方式比较重要，一定需要记住这种求解方式。

```cpp
vector<vector<int>> res;

vector<vector<int>> subsets(vector<int>& nums) {
    // 记录走过的路径
    vector<int> track;
    backtrack(nums, 0, track);// 除了排列之外一般的组合和子集问题都需要将开始索引输入进去，输入开始索引是比较正常的一件事情。
    return res;
}
void backtrack(vector<int>& nums, int start, vector<int>& track) {
    res.push_back(track);// 不要添加return 语句，因为我们需要遍历所有的
    for (int i = start; i < nums.size(); i++) {
        // 做选择
        track.push_back(nums[i]);
        // 回溯
        backtrack(nums, i + 1, track);
        // 撤销选择
        track.pop_back();
    }
}
```

#### 13.6 组合问题(元素无重不可复选)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

[77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/description/)

```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> combine(int n, int k) {
        vector<int> track;
        backtrance(track,1,n,k);
        return res;    
    }

    void backtrance(vector<int> &track, int start_index,int n, int k){
        if(track.size()==k){
            res.push_back(track);
            return;
        }
        for(int i = start_index;i<=n;i++){
            track.push_back(i);
            backtrance(track, i+1, n, k);
            track.pop_back();
        }
    }
};
```

#### 13.7 子集(元素可重复不可复选)

[90. 子集 II - 力扣（LeetCode）](https://leetcode.cn/problems/subsets-ii/)

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

这里是子集遍历的图像，可以发现，两个值相同的树枝会产生重复。



<img src="./asserts/26.jpg" style="zoom:33%;" />



所以在每一层都需要判断不要出现两个相同的

```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        std::sort(nums.begin(),nums.end());// 对数组进行排序(重小到大进行排序) 在组合问题上首先进行排序
        vector<int> track;
        backtrance(nums, track,0);
        return res;
    }
    void backtrance(vector<int>& nums,vector<int> track,int start_index){
        res.push_back(track);
        for(int i=start_index;i<nums.size();i++){//// 第一个没有前面的索引不能急进行判断
            if(i!=start_index&&nums[i]==nums[i-1]) continue;//增加了一个判断逻辑(防止出现相同的树枝) 注意这里第一项逻辑判断比较重要非常重要
            track.push_back(nums[i]);
            backtrance(nums,track,i+1);
            track.pop_back();
        }
    }
};
```

#### 13.8 组合(元素可重复不可复选)

这几道元素组合之和一定需要进行减枝操作。

[力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台](https://leetcode.cn/problems/combination-sum-ii/submissions/)

```cpp
class Solution {
public:
    vector<vector<int>> res; 
    int target;
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        std::sort(candidates.begin(),candidates.end());
        this->target = target;
        vector<int> track;
        backtrance(candidates,track,0,0);
        return res;
    }
    void backtrance(vector<int>& nums,vector<int> track,int start_index,int sum){
        if(sum>target) return;//进行减枝操作(涉及到判断和相等一定需要进行减枝操作)
        if(sum==target) res.push_back(track);
        
        for(int i=start_index;i<nums.size();i++){
            if(i!=start_index&&nums[i-1]==nums[i]) continue;
             backtrance(nums,track,i+1,sum+nums[i]);
            track.pop_back();
        }
    }
};

```

#### 13.9 排列(元素可重复不可复选)

[47. 全排列 II - 力扣（LeetCode）](https://leetcode.cn/problems/permutations-ii/)

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

这里需要着重注意一下，不能直接就返回。因为排列问题每一层的遍历都是从头开始的，以至于每一个节点都会添加上。从而导致如果出现相同的元素的话，会造成后面的



减枝的逻辑如下：

```cpp
// 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置
if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
    // 如果前面的相邻相等元素没有用过，则跳过
    continue;
}
```

**当出现重复元素时，比如输入 `nums = [1,2,2',2'']`，`2'` 只有在 `2` 已经被使用的情况下才会被选择，同理，`2''` 只有在 `2'` 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定**。



```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        std::sort(nums.begin(),nums.end()); //将数组进行排序操作
        vector<int> track;
        unordered_set<int> used_index;//  用于判断某一个索引是否被使用过
        back_trance(nums, track, used_index);
        return res;
    }
    void back_trance(vector<int>& nums, vector<int> track, unordered_set<int> used_index){
        if(nums.size()==track.size()){
            res.push_back(track);
            return;
        };             
        for(int i =0;i<nums.size();i++){
            if(i>0&&nums[i]==nums[i-1]&&used_index.find(i-1)!=used_index.end()) continue;// i-1这个索引需要被使用过
            if(used_index.find(i)!=used_index.end()) continue;// 该索引在前面已经使用过了，那就不必再使用了

            used_index.insert(i);
            track.push_back(nums[i]);
            back_trance(nums, track, used_index);
            track.pop_back();
            used_index.erase(i);
        }
    }
};



class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        std::sort(nums.begin(),nums.end()); //相同的元素会排列放在一起
        vector<int> track;
        unordered_set<int> index_set;
        backtrance(nums,track,index_set);
        return res;
    }
    void backtrance(vector<int>& nums, vector<int> track, unordered_set<int> index_set){
        if(track.size()==nums.size()){// 总数达到了才会返回最终结果
            res.push_back(track);
            return;
        }
        for(int i=0;i<nums.size();i++){
            // 还要避免产生相同的分支
            if(i>0&&nums[i-1]==nums[i]&&index_set.count(i-1)==1) continue;
            if(index_set.count(i)==1) continue;
            index_set.insert(i);
            track.push_back(nums[i]);
            backtrance(nums,track,index_set);
            track.pop_back();
            index_set.erase(i);
        }
    }
};
```

#### 13.10 组合问题(元素无重可复选)

[39. 组合总和 - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum/)

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

每一层都只能遍历往后的索引，只有遍历往后的索引才可以避免出现重复的数据。



<img src="./asserts/27.jpg" style="zoom:33%;" />

每一个分支遍历的索引是一样的。

```cpp
class Solution {
public:
    vector<vector<int>> res; 
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
            vector<int> track;
            back_trance(candidates, target, track, 0, 0);
            return res;
    }
    void back_trance(vector<int>& nums,int &target,vector<int> track, int sum, int start_index){
        if(sum>target) return;//减枝操作
        if(sum==target){
            res.push_back(track);
            return;
        }
        if(res.size()>=150) return;

        for(int i=start_index;i<nums.size();i++){
            //这里还有一个重复判断的逻辑不知道怎么去添加。
            track.push_back(nums[i]);
            back_trance(nums,target,track,sum+nums[i],i);//和前面唯一的区别就是这里开始的索引不一样。这里开始的索引是值得详细记住的。
            track.pop_back();
        }
    }
};
```





13.11 排列(元素无重可复选) 没有对应的题目

```cpp
// 本代码还未经过力扣测试，仅供参考，如有疑惑，可以参照我写的 java 代码对比查看。

class Solution {
public:
    vector<vector<int>> res;
    deque<int> track;

    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        backtrack(nums);
        return res;
    }

    void backtrack(vector<int>& nums) {
        if (track.size() == nums.size()) {
            res.push_back(vector(track.begin(), track.end()));
            return;
        }

        for (int i = 0; i < nums.size(); i++) {
            //剪枝操作，判断当前节点是否已经在track中
            if (i > 0 && nums[i] == nums[i - 1] && find(track.begin(), track.end(), nums[i - 1]) != track.end()) {
                continue;
            }
            track.push_back(nums[i]);
            backtrack(nums);
            track.pop_back();
        }
    }
};
```

#### 13.11 划分为k个相同的子集

[698. 划分为k个相等的子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)

解法①：以数字的视角来看

```cpp
class Solution {
public:
    // 这题有一点类似于N皇后
    // 以桶的视角来看的话就是n皇后问题
    // 遍历nums数组的每一个元素，每一次选择将元素放在k个桶中的哪一个
    bool flag=false;
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        // 排除可以直接进行判断的基本情况
        if(k>nums.size()) return false;
        int sum = 0;
        for (int num : nums) sum += num;
        if (sum % k != 0) return false;
        int target = sum / k;
        vector<int> bucket(k,0);       // 初始化k个集合
        backtrack(nums,bucket,sum/k,0);
        return flag;
    }
    void backtrack(vector<int>& nums,vector<int> bucket, int target,int index){
        if(index==nums.size()){//决定完最后一个数字的归属问题之后
            for(int i=0;i<bucket.size();i++){
                if(bucket[i]!=target){
                    return;
                }
            }
            flag=true;
            return;//全部都满足的话则返回true
        }
        for(int i=0;i<bucket.size();i++){
            // 判断该桶是否可以添加该元素
            if(bucket[i]+nums[index]>target) continue;
            bucket[i]+=nums[index];
            backtrack(nums, bucket, target, index+1);
            bucket[i]+=nums[index];
        }
    }
};
```

解法②：以桶的视角来看

```cpp
class Solution {
public:
    bool flag =false;
    // 下面以桶的视角来看待回溯问题
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        //排除掉非法情况
        if(k>nums.size()) return false;
        int sum = 0;
        for(int x:nums) sum+=x;
        if(sum%k!=0) return false;
        // 开始以桶的视角进行判断，把每一个桶都填满到目标数字之后才可以进行操作
        unordered_set<int> used_index;//用于记录使用过的索引
        back_trance(nums,k,sum/k,used_index,0);
        return flag;
    }
    // 每一个回溯函数负责将当前桶添加满，同时能够添加下一桶
    void back_trance(vector<int>& nums, int k, int target,unordered_set<int> used_index, int cur_sum){
        // 整个程序结束的标志
        if(k==0){//如果最后一个桶被添加满了
            flag = true;
            return;
        }
        if(cur_sum>target) return;
        // 只有前一个桶被添加满了，才有机会添加下一个桶
        if(cur_sum==target){
            back_trance(nums, k-1,target,used_index,0);//将当前桶的标记以及桶内总和更新。
            return;
        }
        for(int i=0;i<nums.size();i++){
            if(used_index.find(i)!=used_index.end()) continue;
            if(cur_sum+nums[i]>target) continue;
            used_index.insert(i);
            back_trance(nums, k, target,used_index,cur_sum+nums[i]);
            used_index.erase(i);
        }
    }
};
```

### 14、DFS岛屿问题

**岛屿系列题目的核心考点就是用 DFS/BFS 算法遍历二维数组**。

遍历框架如下图所示：

```cpp
void dfs(vector<vector<int>>& grid, int i, int j, vector<vector<bool>>& visited) {
    int m = grid.size(), n = grid[0].size();
    if (i < 0 || j < 0 || i >= m || j >= n) {
        return;
    }
    if (visited[i][j]) {
        return;
    }
    visited[i][j] = true;
    dfs(grid, i - 1, j, visited); // 上
    dfs(grid, i + 1, j, visited); // 下
    dfs(grid, i, j - 1, visited); // 左
    dfs(grid, i, j + 1, visited); // 右
}
```

#### 14.1 岛屿数量

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

[力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台](https://leetcode.cn/problems/number-of-islands/submissions/)

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        int res = 0;
        //vector<vector<bool>> visied(m,vector<bool>(n,false));
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    res++;
                    dfs(grid,i,j);
                }
            }
        }
        return res;
    }
    void dfs(vector<vector<char>>& grid,int cur_i, int cur_j){
        if(cur_i<0||cur_i>=grid.size()||cur_j<0||cur_j>=grid[0].size()){
            return;
        }
        if(grid[cur_i][cur_j]=='0'){
            return;
        }
        grid[cur_i][cur_j]='0';     // 否则就将其设置为海水
        dfs(grid,cur_i-1,cur_j);
        dfs(grid,cur_i+1,cur_j);
        dfs(grid,cur_i,cur_j-1);
        dfs(grid,cur_i,cur_j+1);
    }
};
```

#### 14.2 封闭岛屿数量

[1254. 统计封闭岛屿的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-closed-islands/)

思路和前面岛屿一样，但是需要提前把靠近边界的岛屿给去掉。

```cpp
class Solution {
public:
    int closedIsland(vector<vector<int>>& grid) {// 这里是int类型的数字
        int res=0;
        int m = grid.size();
        int n = grid[0].size();
        // 需要把靠近边界的岛屿给去除掉
        for(int i=0;i<n;i++) {
            dfs(grid,0,i);
            dfs(grid,m-1,i);
        }
        for(int i=0;i<m;i++){
            dfs(grid,i,0);
            dfs(grid,i,n-1);
        } 
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]==0){
                    res++;
                    dfs(grid,i,j);
                }
            }
        }
        return res;
    }
    
    void dfs(vector<vector<int>>& grid, int cur_i, int cur_j){
        if(cur_i<0||cur_i>=grid.size()||cur_j<0||cur_j>=grid[0].size()) return;
        if(grid[cur_i][cur_j]==1) return;
        grid[cur_i][cur_j]=1;  // 将当前位置设置为土地
        // 深度优先策略
        dfs(grid,cur_i-1,cur_j);
        dfs(grid,cur_i+1,cur_j);
        dfs(grid,cur_i,cur_j-1);
        dfs(grid,cur_i,cur_j+1);
    }
};
```

#### 14.3 岛屿最大面积

[一文秒杀所有岛屿题目 | labuladong 的算法小抄 (gitee.io)](https://labuladong.gitee.io/algo/di-san-zha-24031/bao-li-sou-96f79/yi-wen-mia-4f482/)

在dfs的迭代过程中需要返回每一个岛屿的面积，返回了每一个岛屿的面积才更加合理。

```cpp
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int m =grid.size();
        int n = grid[0].size();
        int res = 0;
        for(int i =0;i<m;i++){
            for(int j =0;j<n;j++){
                if(grid[i][j]==1){
                    res=std::max(dfs(grid,i,j),res);
                }
            }
        }
        return res;
    }

    int dfs(vector<vector<int>>& grid, int i, int j){
        int m =grid.size();
        int n = grid[0].size();
        if(i<0||i>=m||j<0||j>=n) return 0;
        if(grid[i][j]==0) return 0;
        grid[i][j]=0;
        int a = dfs(grid, i-1,j);
        int b = dfs(grid, i+1,j);
        int c = dfs(grid, i,j-1);
        int d = dfs(grid, i,j+1);
        return a+b+c+d+1;    // 这个地方是关键
    }
};
```

#### 14.4 统计子岛屿的个数

[1905. 统计子岛屿 - 力扣（LeetCode）](https://leetcode.cn/problems/count-sub-islands/description/)

输入进去的是两个grid.

```cpp
class Solution {
public:
    // 统计子岛屿的个数
    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {
        int m = grid1.size();
        int n = grid1[0].size();
        int res = 0;
        // 相当于遍历两次
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid1[i][j]==0&&grid2[i][j]==1){
                    dfs(grid2,i,j);
                }
            }
        }
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid2[i][j]==1){
                    dfs(grid2,i,j);
                    res++;
                }
            }
        }

        return res;
    }

    void dfs(vector<vector<int>> &grid, int i, int j){
        int m = grid.size();
        int n = grid[0].size();
        if(i<0||i>=m||j<0||j>=n) return;
        if(grid[i][j]==0) return;
        grid[i][j]=0;
        dfs(grid,i-1,j);
        dfs(grid,i+1,j);
        dfs(grid,i,j-1);
        dfs(grid,i,j+1);
    }
};
```

#### 14.5 不同的岛屿数量

题目需要花钱，暂时不放置改题目链接。

输入一个二维矩阵，0表示海水，1表示陆地，计算不同的岛屿数量。



<img src="https://labuladong.gitee.io/algo/images/%E5%B2%9B%E5%B1%BF/5.jpg" alt="img" style="zoom: 50%;" />



上图中不同的岛屿数量就是3个



<img src="https://labuladong.gitee.io/algo/images/%E5%B2%9B%E5%B1%BF/6.png" alt="img" style="zoom: 33%;" />



**核心代码类似于二叉树的序列化**

```cpp
int numDistinctIslands(vector<vector<int>> grid){
    int m = grid.size();
    int n = grid.size[0]();
    unordered_set<std::string> save;
    for(int i=0;i<m;i++){
        for(int j=0;i<n;j++){
            if(grid[i][j]==1){
                string cur_island = "";
                // 初始方向可以随便写，不影响正确定
                dfs(grid,i,j,cur_island,666);
                islands.insert(curIsland);
            }
        }
    }
    return save.size();
}
std::string dfs(vector<vector<int>> &grid, int i, int j, string& sb, int order){
    int m = grid.size();
    int n = grid[0].size();
    if(i<0||i>=m||j<0||j>=n) return;
    if(grid[i][j]==0) return;// 该处是水，就不用遍历了
    grid[i][j]=0;// 已经遍历了，将该处设置为水
    sb += to_string(dir) + ',';
    dfs(grid,i-1,j,sb,1);// 引用传递，会一步步进入其中
    dfs(grid,i+1,j,sb,2);
    dfs(grid,i,j-1,sb,3);
    dfs(grid,i,j+1,sb,4);
    sb += to_string(-dir) + ',';
}
```

### 15、BFS广度优先

[Dijkstra 算法模板及应用 | labuladong 的算法小抄 (gitee.io)](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/dijkstra-s-6d0b2/)

前面有BFS算法的一些引用场景。

```cpp
int BFS(Node start, Node target) {
    queue<Node> q; 
    set<Node> visited;
    
    q.push(start); 
    visited.insert(start);

    while (!q.empty()) {
        int sz = q.size();
        for (int i = 0; i < sz; i++) {// 这个循环其实只是为了方便我们获得深度的信息
            Node cur = q.front();
            q.pop();
            // 结束的逻辑放在for循环里面。
            if (cur == target)
                return step;
            for (Node x : cur.adj()) {
                if (visited.count(x) == 0) {
                    q.push(x);
                    visited.insert(x);
                }
            }
        }
    }
    // 如果走到这里，说明在图中没有找到目标节点
}
```

#### 15.1 二叉树最小深度

① 通过遍历方法

```cpp
class Solution {
public:
    int res=INT_MAX;
    int minDepth(TreeNode* root) {
        if(root==nullptr) return 0;
        int depth=1;
        backtrance(root,depth);
        return res;
    }
    void backtrance(TreeNode* root, int depth){
        if(root==nullptr) return;
        
        if(root->left==nullptr&&root->right==nullptr){
            res = std::min(res,depth);
            return;
        }
        backtrance(root->left, depth+1);
        backtrance(root->right, depth+1);
    }
};
```

②通过分解子问题的方法

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root==nullptr) return 0;
        int min_depth = backtrance(root);
        return min_depth;
    }
	// 输入一个二叉树，返回二叉树的最小深度
    int backtrance(TreeNode* root){
        if(root==nullptr) return 0;
        int min_left = backtrance(root->left);
        int min_right = backtrance(root->right);
        // 对于一个节点来说，存在三种情况
        // 1.两个子节点都为0，说明为叶子节点,直接返回1
        // 2.其中的一个子节点为0,那最小深度只能通过判断另一个子节点
        // 3.两个节点均不为0,那就继续往下寻找
        if(min_left==0&&min_right==0) return 1;
        if(min_left*min_right==0) return min_left+min_right+1;//其中一个为0，另一个不为0
        return std::min(min_left,min_right)+1; // 两个子节点都不为空(表明两个子节点都不为空)
    }
};
```

③通过BFS层序遍历的方式

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root==nullptr) return 0;
        return bfs(root);
    }

    int bfs(TreeNode* root){
        std::queue<TreeNode*> q;
        q.push(root);
        TreeNode* node;
        int level=0;// 一个参数用于记录当前的层数
        while(!q.empty()){
            int size = q.size();
            level++;
            for(int i=0;i<size;i++){
                node = q.front();
                q.pop();
                // 返回第一次遇到的叶子节点
                if(node->left==nullptr&&node->right==nullptr) return level;
                if(node->left!=nullptr) q.push(node->left);
                if(node->right!=nullptr) q.push(node->right);
            }
        }
        return level;
    }
};
```

#### 15.2 最小打开转盘锁的最小次数

[752. 打开转盘锁 - 力扣（LeetCode）](https://leetcode.cn/problems/open-the-lock/)

比如说从 `"0000"` 开始，转一次，可以穷举出 `"1000", "9000", "0100", "0900"...` 共 8 种密码。然后，再以这 8 种密码作为基础，对每个密码再转一下，穷举出所有可能...

这就类似于一个图结构。

**BFS算法在笔试中非常重要，是一个常考的算法。**

```cpp
class Solution {
public:
    int openLock(vector<string>& deadends, string target) {
        // 目标字符串以及需要略过的字符串
        std::unordered_set<std::string> dead_set;
        for(auto x:deadends) dead_set.insert(x);
        int num = bfs(dead_set, target);
        return num;
    }
    int bfs(std::unordered_set<std::string>& dead_set,string &target){
        std::string str = "0000"; 
        std::queue<std::string> q;
        std::unordered_set<std::string> visied;
        q.push(str);      
        visied.insert(str);
        int res = 0;
        
        while(!q.empty()){
            int size = q.size();
            for(int i=0;i<size;i++){
                std::string cur_str = q.front();
                q.pop();
                // 如果该数字为死亡数字，则直接无需对死亡数字再次进行转动，也不需要添加接下来的情况
                if(dead_set.count(cur_str)==1) continue;
                if(cur_str==target) return res;
                
                for(int j=0;j<4;j++){ 
                    std::string up_str = up_tone(cur_str,j);
                    if(visied.count(up_str)==0){
                        q.push(up_str);  //向上调的结果放进去
                        visied.insert(up_str);
                    }
                    std::string down_str = down_tone(cur_str,j);
                    if(visied.count(down_str)==0){
                        q.push(down_str);//向下调的结果放进去
                        visied.insert(down_str);
                    }
                }
            }
            res++;// 这里才是记录层数的
        }
        return -1;
    }

    // 向上拨动一次(字符串以及拨动位置i,i为0,1,2,3) 数字增加
    std::string up_tone(std::string str, int i) {
        if (str[i] == '9') {
            str[i] = '0';
            return str;
        }
        str[i] += 1;
        return str;
    }
    // 向下拨动一次(字符串以及拨动位置i,i为0,1,2,3) 数字减小
    std::string down_tone(std::string str, int i){
        if (str[i] == '0') {
            str[i] = '9';
            return str;
        }
        str[i] -= 1;
        return str;
    }
};
```

#### 15.3 BFS算法智力题拼图问题

[773. 滑动谜题 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-puzzle/description/)

拼图问题

BFS算法的关键在于如何根据一个状态推导出接下来的状态

```cpp
class Solution {
public:
    int slidingPuzzle(vector<vector<int>>& board) {
        // 0位置在不同的位置所对应的接下来的位置
        std::vector<vector<int>> str_mapping = {{1,3},{0,2,4},{1,5},{0,4},{1,3,5},{2,4}};
        // 最少问题可以通过bfs问题来求解
        std::string board_str ="";//空字符串 
        for(int i =0;i<board.size();i++){
            for(int j =0;j<board[0].size();j++){
                board_str+=std::to_string(board[i][j]);
            }
        }
        std::string target = "123450";//最终需要变换的结果
        std::unordered_set<std::string> visied;//保存已经参观过的字符串(相当于是一个剪枝)
        std::queue<std::string> q;
        q.push(board_str);//
        visied.insert(board_str);
        int step = 0;

        while(!q.empty()){// 如果队列非空的话
            int size = q.size();
            for(int i=0;i<size;i++){
                std::string cur_string = q.front();
                q.pop();//移除掉当前这个字符串
                if(cur_string==target) return step;
                // 都不满足的话接下来就要增加了
                int zero_index = cur_string.find('0');//找到0字符串所处的位置
                for(int x:str_mapping[zero_index]){
                    std::string next_str = get_str_list(cur_string,zero_index,x);
                    if(visied.count(next_str)==0){// 如果没有下一个字符串
                        q.push(next_str);
                        visied.insert(next_str);
                    }
                }
            }
            step++;//每进行一步，step增加1
        }
        return -1;
    }
    // 用于交换字符串两个位置的索引。
    std::string get_str_list(std::string cur_str, int index1, int index2){
        std::swap(cur_str[index1],cur_str[index2]);
        return cur_str;
    }
};
```

#### 15.4 腐烂的橘子

[994. 腐烂的橘子 - 力扣（LeetCode）](https://leetcode.cn/problems/rotting-oranges/description/)

```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        // 求最小值一般选择广度优先搜索算法进行求解
        int m = grid.size();
        int n = grid[0].size();
        queue<pair<int,int>> q;
        pair<int,int> temp;
        int orange_num=0;
        // 收集数据阶段
        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[0].size();j++){
                if(grid[i][j]==2){
                    temp.first = i;
                    temp.second = j;
                    q.push(temp);
                }
                if(grid[i][j]==1||grid[i][j]==2){
                    orange_num++;
                }
            }
        }
        int bad_sum=0;
        int time = 0;
        while(!q.empty()){
            int size = q.size();
            bad_sum+=size;
            for(int i=0;i<size;i++){
                pair<int,int> node = q.front();
                q.pop();
                // 让上下左右的橘子进行腐烂
                orange(grid,q,node.first-1,node.second,m,n);// 上
                orange(grid,q,node.first+1,node.second,m,n);// 下
                orange(grid,q,node.first,node.second-1,m,n);// 左
                orange(grid,q,node.first,node.second+1,m,n);// 右
            }
            if(q.size()!=0) time++;// 只有该橘子周围存在未腐烂的橘子时，才能将时间加上1
        }
        if(orange_num==bad_sum) return time; 
        return -1;
    }
    
	// 处理某一个坐标系下面的橘子
    void orange(vector<vector<int>>& grid,queue<pair<int,int>> &q,int i,int j, int m, int n){
        if(i<0||i>=m||j<0||j>=n){
            return;
        }
        // 等于0或者等于2的话就没有进行任何操作。
        if(grid[i][j]==1){
            grid[i][j]=2;
            pair<int,int> temp;
            temp.first = i;
            temp.second = j;
            q.push(temp);
        }
    }
};
```



### 16、图论基础以及遍历算法



<img src="https://labuladong.gitee.io/algo/images/%E5%9B%BE/3.jpeg" alt="img" style="zoom: 33%;" />





如何构造图？

常常使用邻接表和邻接矩阵实现图数据结构



<img src="https://labuladong.gitee.io/algo/images/%E5%9B%BE/2.jpeg" alt="img" style="zoom:33%;" />





对于邻接表来说，其占用的空间较小。

图的其他概念：

图论中度的概念：在无向图中，度就是每一个节点相连的边的条数。

对于有向图来说，所有有向图中的每一个节点被细分为入度和出度。入度为指向该节点的边的个数，出度为从该节点出去的边的个数。

如何实现有向加权图？如果是邻接表，不仅保存某个节点x的邻居节点，还保存x到每一个邻居的权重。

对于邻接矩阵，矩阵中每一个数值不再是一个bool值，而是一个int类型的值，0表示没有连接，其他值表示权重。



图的遍历类似于二叉树的遍历。图和多叉树最大的区别就是图是可能包含环的，从图的某一个节点开始遍历，有可能走了一圈又回到这个节点，而树不会出现这种情况。

对于图数据结构来说，可能从每一个节点开始依次进行遍历。图和二叉树的结构存在较多的不同。



```cpp
// 记录被遍历过的节点
vector<bool> visited;
// 记录从起点到当前节点的路径
vector<bool> onPath;

/* 图遍历框架 */
void traverse(Graph graph, int s) {
    if (visited[s]) return;// 如果该图已经被参观过了直接返回。
    // 经过节点 s，标记为已遍历
    visited[s] = true;                                            // 这个是全局的变量
    // 做选择：标记节点 s 在路径上
    onPath[s] = true;// 关注的是当前节点(从上到下走过的所有的路径信息)
    for (int neighbor : graph.neighbors(s)) {
        traverse(graph, neighbor);
    }
    // 撤销选择：节点 s 离开路径
    onPath[s] = false;
}

```

另外，你应该注意到了，这个 `onPath` 数组的操作很像前文 [回溯算法核心套路](https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/) 中做「做选择」和「撤销选择」，区别在于位置：回溯算法的「做选择」和「撤销选择」在 for 循环里面，而对 `onPath` 数组的操作在 for 循环外面。



#### 16.1 所有可能的路径

[797. 所有可能的路径 - 力扣（LeetCode）](https://leetcode.cn/problems/all-paths-from-source-to-target/)

给你一个有 `n` 个节点的 **有向无环图（DAG）**，请你找出所有从节点 `0` 到节点 `n-1` 的路径并输出（**不要求按特定顺序**）

 `graph[i]` 是一个从节点 `i` 可以访问的所有节点的列表（即从节点 `i` 到节点 `graph[i][j]`存在一条有向边）。

①自己求解的方法

其实图遍历有一点类似于二叉树的遍历。

```cpp
class Solution {
public:
    vector<vector<int>> res;// 记录某一次路径的所有的的列表
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        vector<int> track;// 用于记录所有的可能的轨迹信息
        all_graph(graph,0,track);
        return res;
    }
    void all_graph(vector<vector<int>>& graph, int cur_node, vector<int> track){
        track.push_back(cur_node);// 注意这个地方开始就需要添加
        if(cur_node==graph.size()-1){
            res.push_back(track);
            return;
        }
        // 遍历所有分支
        for(int x:graph[cur_node]){
            all_graph(graph, x, track);
        }
    }
};
```

#### 16.2 环检测和拓扑排序

==1.DFS版本的环检测算法==

- 题目一：环检测算法(检测在一个列表中是否是存在环信息)

[207. 课程表 - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule/)

环检测和拓扑排序都分为BFS和DFS算法

```cpp
class Solution {
public:
    bool flag = true;
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> graph = build_graph(numCourses, prerequisites);//邻接表
        vector<bool> visited(numCourses,false);
        for(int i=0;i<numCourses;i++){
            vector<bool> one_path(numCourses,false);
            dfs(graph,one_path,visited,i);// 从节点i开始进行深度优先搜索
        }
        return flag;
    }

    void dfs(vector<vector<int>> &graph, vector<bool> &one_path, vector<bool> &visited, int node){
        // 检测到环，直接结束
        if(one_path[node]==true){
            flag = false;
            return;
        }
        if(visited[node]==true) return;// 该节点之前检测过，不需要重复进行检测
        one_path[node] = true;
        visited[node] = true;
        // 检测该节点的下一个节点
        for(int n:graph[node]){
            dfs(graph,one_path,visited,n);
        }
        one_path[node] = false;
    }

    vector<vector<int>> build_graph(int numCourses, vector<vector<int>>& prerequisites){
        vector<vector<int>> res(numCourses,vector<int>());
        for(vector<int> v:prerequisites){
            res[v[1]].push_back(v[0]);
        }
        return res;
    }
};
```



- 题目二：拓扑排序算法

很显然，如果一幅有向图中存在环，是无法进行拓扑排序的，因为肯定做不到所有箭头方向一致；反过来，如果一幅图是「有向无环图」，那么一定可以进行拓扑排序。

[210. 课程表 II - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule-ii/description/)

```cpp
class Solution {
public:
    bool has_cir = false;
    vector<int> record;
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> graph = buildGraph(numCourses, prerequisites);
        vector<bool> visied(numCourses,false);
        // 遍历每一门课
        vector<int> res(numCourses,0);
        for (int i = 0; i < numCourses; i++) {
            vector<bool> onepath(numCourses, false);
            trance(graph,i, visied, onepath);
            if (has_cir) return {};//存在环则返回空数组
        }
        
        for (int i = 0; i < numCourses; i++) {
            res[i] = record[i];
        }
        //std::reverse(res.begin(), res.end());
        return res;
    }
    void trance(vector<vector<int>> &graph, int cur_node, vector<bool> &visied, vector<bool> &onepath) {
        if (onepath[cur_node]) {
            has_cir = true;
            return;
        }
        if (visied[cur_node]||has_cir) {// 如果该节点已经存在环了就不需要再去检测后面的环了
            return;
        }
        onepath[cur_node] = true;
        visied[cur_node] = true;
        for (int x : graph[cur_node]) {
            trance(graph,x, visied, onepath);
        }
        onepath[cur_node] = false;//后续遍历
        record.push_back(cur_node);// 在二叉树遍历的后序位置添加信息
    }

    // 根据输入建造图的邻接矩阵
    vector<vector<int>> buildGraph(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> graph(numCourses, vector<int>());
        for (auto v : prerequisites) {
            graph[v[0]].push_back(v[1]);
        }
        return graph;
    }
};
```

==2.BFS版本的环检测算法==

环形检测的流程如下图所示。

<img src="./asserts/30.png" style="zoom:50%;" />

利用入度和出度信息进行检测。每一次检查入度为0的节点，并且将该节点指向的节点的入度减去1，如果该子节点的入度为0,那就将该节点也加入到队列中，继续进行遍历。

```cpp
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // 返回建造的图的结构
        vector<vector<int>> graph = build_graph(numCourses,prerequisites);
        // 构建一个每一个节点入度的数组
        vector<int> indegree(numCourses, 0);// 初始时刻所有节点的入度都为0
        for(auto x:prerequisites){
            indegree[x[1]]++;
        }
        // 每一次遍历的都是入度为0的节点
        queue<int> q;// 记录入度为0的节点
        for(int i=0;i<indegree.size();i++){
            if(indegree[i]==0) q.push(i);
        }
        int visited_node  = 0;
        bool flag = false;
        // 到q队列非空时
        while(!q.empty()){
            int size = q.size();
            for(int i =0;i<size;i++){
                int cur_node = q.front();  //队里最前面的那个元素
                q.pop();
                visited_node++;
                for(int node:graph[cur_node]){
                    indegree[node]--;      // 该节点的入度减去1
                    if(indegree[node]==0){ // 如果该节点的入度为0
                        q.push(node);      // 那就将该节点添加进去
                    }
                }
            }
        }
        if(visited_node==numCourses) flag=true;
        return flag;
    }   
    // 将问题抽象为图的邻接表形式，然后将边的信息加入到邻接表中。
    vector<vector<int>> build_graph(int numCourses, vector<vector<int>>& prerequisites){
        vector<vector<int>> res(numCourses,vector<int>());
        for(auto x:prerequisites){
            res[x[0]].push_back(x[1]);
        }
        return res;
    }
};
```

BFS版本的拓扑排序。

```cpp
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> track;
        vector<vector<int>> graph = build_graph(numCourses,prerequisites);
        vector<int> indegree(numCourses,0);// 记录入度的个数
        for(auto x:prerequisites){
            indegree[x[0]]++;
        }
        // 向其中增加
        queue<int> q;
        for(int i=0;i<indegree.size();i++){
            if(indegree[i]==0) q.push(i);// 节点序号
        }
        while(!q.empty()){
            int size = q.size();
            for(int i=0;i<size;i++){
                int cur_node  = q.front();
                q.pop();
                track.push_back(cur_node);
                for(int x:graph[cur_node]){
                    indegree[x]--;
                    if(indegree[x]==0){
                        q.push(x);
                    }
                }
            }
        }
        if(track.size()==numCourses) return track;
        return {};
    }
    // 建图的节点方向和前面是不一样的。注意建图的节点方向是比较重要的
    vector<vector<int>> build_graph(int numCourses, vector<vector<int>>& prerequisites){
        vector<vector<int>> res(numCourses, vector<int>());
        for(auto x:prerequisites){
            res[x[1]].push_back(x[0]);
        }
        return res;
    }
};
```



#### 16.3 Dijkstra算法

Dijkstra算法是由广度优先算法发展而来；

二叉树层序遍历。

```cpp
int levelTraverse(TreeNode* root) {
    if (root == nullptr) return 0;
    queue<TreeNode*> q;
    q.push(root);

    int depth = 1;
    // 从上到下遍历二叉树的每一层
    while (!q.empty()) {
        int sz = q.size();
        // 从左到右遍历每一层的每个节点
        for (int i = 0; i < sz; i++) {
            TreeNode* cur = q.front();
            q.pop();
            printf("节点 %s 在第 %s 层", cur, depth);

            // 将下一层节点放入队列
            if (cur->left != nullptr) {
                q.push(cur->left);
            }
            if (cur->right != nullptr) {
                q.push(cur->right);
            }
        }
        depth++;
    }
    return depth;
}
```

多叉树层序遍历

```cpp
void levelTraverse(TreeNode* root) {
    if (root == nullptr) return;
    queue<TreeNode*> q;
    q.push(root);

    int depth = 1;
    while (!q.empty()) {
        int sz = q.size();
        for (int i = 0; i < sz; i++) {
            TreeNode* cur = q.front();
            q.pop();
            printf("节点 %s 在第 %s 层", cur, depth);

            for (auto child : cur->children) {
                q.push(child);
            }
        }
        depth++;
    }
}
```

BFS框架

```cpp
#include <queue>
#include <set>

// 输入起点，进行 BFS 搜索
int BFS(Node* start) {
    std::queue<Node*> q; // 核心数据结构
    std::set<Node*> visited; // 避免走回头路
    
    q.push(start); // 将起点加入队列
    visited.insert(start);// 需要有一个参观过的set容器。

    int step = 0; // 记录搜索的步数
    while (!q.empty()) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散一步 */
        for (int i = 0; i < sz; i++) {
            Node* cur = q.front();
            q.pop();
            printf("从 %s 到 %s 的最短距离是 %s", start->val, cur->val, step);

            /* 将 cur 的相邻节点加入队列 */
            for (Node* x : cur->adj()) {
                if (visited.count(x) == 0) {// 如果之前遇到过则向队列中增加
                    q.push(x);
                    visited.insert(x);
                }
            }
        }
        step++;
    }
}
```

Dijkstra算法

```cpp
// 返回节点 from 到节点 to 之间的边的权重
int weight(int from, int to);

// 输入节点 s 返回 s 的相邻节点
List<Integer> adj(int s);

// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离
int[] dijkstra(int start, List<Integer>[] graph) {
    // 图中节点的个数
    int V = graph.length;
    // 记录最短路径的权重，你可以理解为 dp table
    // 定义：distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重
    int[] distTo = new int[V];
    // 求最小值，所以 dp table 初始化为正无穷
    Arrays.fill(distTo, Integer.MAX_VALUE);
    // base case，start 到 start 的最短距离就是 0
    distTo[start] = 0;

    // 优先级队列，distFromStart 较小的排在前面
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
        return a.distFromStart - b.distFromStart;
    });

    // 从起点 start 开始进行 BFS
    pq.offer(new State(start, 0));// 将开始状态加入进去

    while (!pq.isEmpty()) {
        State curState = pq.poll();// 拿到并且弹出
        int curNodeID = curState.id;
        int curDistFromStart = curState.distFromStart;

        if (curDistFromStart > distTo[curNodeID]) {
            // 已经有一条更短的路径到达 curNode 节点了
            continue;
        }
        // 将 curNode 的相邻节点装入队列
        for (int nextNodeID : adj(curNodeID)) {
            // 看看从 curNode 达到 nextNode 的距离是否会更短
            int distToNextNode = distTo[curNodeID] + weight(curNodeID, nextNodeID);
            if (distTo[nextNodeID] > distToNextNode) {
                // 更新 dp table
                distTo[nextNodeID] = distToNextNode;
                // 将这个节点以及距离放入队列
                pq.offer(new State(nextNodeID, distToNextNode));// 加进去
            }
        }
    }
    return distTo;
}
```

#### 16.4 网络延迟问题(经典dijkstra问题)

**dist[i]**用于记录从开始节点到当前节点i的最近距离。

**weight [i] [j] **用于记录从节点i到节点j之间的最短距离。

**adj[i]**用于表示节点i的所有的邻居节点。

dijkstra用于求解从一个起点到达其他的所有的起点的最短路径，相比于BFS，其更加适合于求解带有权重的边的问题。

可以直接使用的前提是不存在负权重的边。负权重的边存在相关的问题。

[743. 网络延迟时间 - 力扣（LeetCode）](https://leetcode.cn/problems/network-delay-time/description/)



求得最短距离中最大的那个值是多少

```cpp
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        unordered_map<int,unordered_map<int,int>> weight;// 两层容器作为系数
        vector<vector<int>> adj(n+1,vector<int>());// adj[i]表示i接下来该走的值的信息
        // 这里都在构造图的过程中
        for(vector<int> x:times){
            weight[x[0]][x[1]]=x[2];
            adj[x[0]].push_back(x[1]);// 给邻接矩阵赋值
        }
        vector<int> dist(n+1, INT_MAX);// 初始都赋值为最大值,注意这里是n+1个
        dist[k] = 0;// 起始点，最远距离就为0
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> q;// 
        q.push(make_pair(k,0));

        // 队列非空的话
        while(!q.empty()){
            pair<int,int> cur = q.top();// 取出队头元素
            q.pop();// 删除队头元素
            if(cur.second>dist[cur.first]){// 经由当前节点的距离更大的话退出。
                continue;
            }
            for(int id:adj[cur.first]){
                // 遍历接下里的每一个id
                int dist_2_next_node = cur.second+weight[cur.first][id];
                if(dist_2_next_node<dist[id]){// 只有距离更短，将接下来的节点加进去才更有意义。
                    dist[id] = dist_2_next_node;// 这里更新距离的操作(更新最短距离的地方，一定不要忘记)
                    q.push(make_pair(id,dist_2_next_node));
                }
            }
        }
        int max_value = *max_element(dist.begin()+1,dist.end());
        return max_value==INT_MAX?-1:max_value;
    }
};
```

#### 16.5 最小体力消耗路径问题。

二维度的最小体力消耗问题。优点类似于动态规划问题。

[1631. 最小体力消耗路径 - 力扣（LeetCode）](https://leetcode.cn/problems/path-with-minimum-effort/description/)

```cpp
// 和前面几乎一样，唯一的难点就是需要自己去构造一些东西。

class Solution {
public:
    // 第一眼选择动态规划的方法来求解，但是感觉好像不太对，存在问题。
    // 使用动态规划的话，完全不知道以何种顺序来遍历数组。
    class state{
    public:
        // 注意这里必须使用初始化列表来赋值否则会存在大问题的。
        state(int row,int col, int val):row(row), col(col), val(val){
        }
        int row;
        int col;
        int val;
    };
    bool is_valid(int row,int col,int cur_row_index,int cur_col_index){
        if(cur_row_index>=0&&cur_row_index<row&&cur_col_index>=0&&cur_col_index<col){
            return true;
        }
        return false;
    }
    vector<vector<int>> adj = {{-1,0},{1,0},{0,-1},{0,1}};// 上下左右
    int minimumEffortPath(vector<vector<int>>& heights) {
        int row = heights.size();
        int col = heights[0].size();
        vector<vector<int>> dist(row,vector<int>(col, INT_MAX));// 都初始化为最大值
        dist[0][0] = 0;// 开始时刻初始化为0
        state temp(0,0,0);
        queue<state> q;
        q.push(temp);
        while(!q.empty()){
            state cur = q.front();
            q.pop();
            if(cur.val>dist[cur.row][cur.col]){
                continue;
            }
            for(vector<int> x:adj){
                // 遍历四个方向
                int next_row = cur.row+x[0];
                int next_col = cur.col+x[1];
                if(is_valid(row,col,next_row,next_col)){
                    int dist_value = max(dist[cur.row][cur.col],abs(heights[cur.row][cur.col]-heights[next_row][next_col]));
                    if(dist_value<dist[next_row][next_col]){
                        dist[next_row][next_col] = dist_value;
                        state  next_node(next_row,next_col,dist_value);
                        q.push(next_node);
                    }
                }
            }

        }
        return dist[row-1][col-1];
    }
};
```

#### 16.6 概率最大的路径

使用dijkstra算法。

[1514. 概率最大的路径 - 力扣（LeetCode）](https://leetcode.cn/problems/path-with-maximum-probability/)

注意这里题目中给出的条件是无向边。因此我们在添加权重的时候需要考虑到这种情况。

使用dijkstra核心就三个地方，也就是

**dist[i]**用于记录从开始节点到当前节点i的最近距离。

**weight [i] [j] **用于记录从节点i到节点j之间的最短距离。

**adj[i]**用于表示节点i的所有的邻居节点。

```cpp
class Solution {
public:
    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start_node, int end_node) {
        vector<double> dist(n,0.0);// 距离
        unordered_map<int,unordered_map<int,double>> weight;
        vector<vector<int>> adj(n,vector<int>());// 一共有n个
        // 添加无向边，所以两个方向都需要添加。
        for(int i =0;i<edges.size();i++){
            weight[edges[i][0]][edges[i][1]] = succProb[i];
            adj[edges[i][0]].push_back(edges[i][1]);
            weight[edges[i][1]][edges[i][0]] = succProb[i];
            adj[edges[i][1]].push_back(edges[i][0]);
        }
        dist[start_node] = 1;// 开始概率为1
        queue<pair<int,double>> q;
        pair<int,double> temp(start_node,1);
        q.push(temp);
        while(!q.empty()){
            pair<int,double> cur = q.front();
            q.pop();
            // 如果经过当前节点到达概率更小
            if(cur.second<dist[cur.first]){
                continue;
            }
            // 
            for(int id:adj[cur.first]){
                double next_pro = cur.second*weight[cur.first][id];
                if(next_pro>dist[id]){          // 只有下一个节点概率最大才会加进去
                    dist[id] = next_pro;
                    q.push(make_pair(id,next_pro));
                }

            }
        }
        return dist[end_node];
    }
};
```

### 17、队列和栈

栈分为单调栈和普通栈。普通栈主要利用了先进后出的原理。一般用于解决括号问题。单调栈一般用于解决求得数组中右边或者左边第一个比他大或者比他小的元素。

#### 17.1 括号题目

①有效的括号

[20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/description/)

```cpp
class Solution {
public:
    bool isValid(string s) {
        if(s.size()==0) return true;
        if(s.size()%2!=0) return false;
        if(s[0]==')'||s[0]==']'||s[0]=='}') return false;
        stack<char> sta;
        for(int i=0;i<s.size();i++){
            if(s[i]==')'||s[i]==']'||s[i]=='}'){
                if(sta.empty()) return false;
                if(sta.top()!=s[i]){
                    return false;
                }
                else{
                    sta.pop();
                }
            }
            // 如果为左括号就往其中添加
            if(s[i]=='(') sta.push(')');
            else if(s[i]=='[') sta.push(']');
            else if(s[i]=='{') sta.push('}');
        }
        return sta.empty();
    }
};
```

②使得括号有效的最少添加次数

这一题只有小圆括号

[921. 使括号有效的最少添加 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/)

```cpp
// 方法一：使用栈这种数据结构
class Solution {
public:
    int minAddToMakeValid(string s) {
        if(s.size()==0) return 0;
        stack<char> sta;// 用于保存栈结构
        int res=0;
        for(int i =0;i<s.size();i++){
            if(s[i]==')'){
                if(sta.empty()){
                    res++;
                }
                else{
                    if(sta.top()!=s[i]){
                        res++;
                    }
                    else{
                        sta.pop();
                    }
                }
            }
            else{
                sta.push(')');
            }
        }
        return res+sta.size();
    }
};
```

③ 平衡括号字符串的最少插入次数

[1541. 平衡括号字符串的最少插入次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/)

#### 17.2 单调栈结构

**单调栈适合求当前元素左边或者右边第一个比当前元素小或者大的元素。**

为什么叫做单调栈呢？因为要保证栈里面的元素是递增或者是递减的。保证这个规则。

要保证从栈口到栈底是递增还是递减的。

单调栈中的元素一定是按照顺序排列的。如果新加入的元素使得栈中的元素打破了这个顺序的话。则就将栈中的元素逐渐弹出。直到栈中的元素满足了这个顺序就可。



①每日温度

[739. 每日温度 - 力扣（LeetCode）](https://leetcode.cn/problems/daily-temperatures/)

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        if(temperatures.size()<=1) return {0};
        vector<int> res(temperatures.size(),0);
        stack<int> sta;// 需要一个从栈口到栈底是递增的。也就是越靠近栈底，元素就是越大
        for(int i=0;i<temperatures.size();i++){
            // !sta.empty()与temperatures[i]>temperatures[sta.top()]的顺序是存在相关性的
            while(!sta.empty()&&temperatures[i]>temperatures[sta.top()]){
                res[sta.top()] =i-sta.top();// 更新res
                sta.pop();// 弹出小的元素
            }
            sta.push(i);// 将当前元素添加进栈结构中
        }
        return res;
    }
};
```

②下一个更大的元素

[496. 下一个更大元素 I - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-i/)

```cpp
// 方法一：使用暴力方法
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        vector<int> res(nums1.size(),-1);   //初始值定义为-1 
        unordered_map<int,int> map;
        for(int i=0;i<nums2.size();i++){
            map[nums2[i]] =i;           // 不包含重复元素，值以及对应的序号
        }
        for(int i =0;i<nums1.size();i++){
            for(int j = map[nums1[i]]+1;j<nums2.size();j++){
                if(nums2[j]>nums1[i]){
                    res[i]=nums2[j];
                    break;
                }
            }
        }
        return res;
    }
};


// 方法二：哈希表+单调栈
// 对nums2进行排序，然后判断nums2的元素是否出现在nums1中
class Solution {
public:
    // 方法二:使用单调栈来求解
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int,int> map;
        for(int i=0;i<nums1.size();i++){
            map[nums1[i]] = i;
        }
        vector<int> res(nums1.size(),-1);
        stack<int> sta;
        for(int i =0;i<nums2.size();i++){
            while(!sta.empty()&&nums2[i]>nums2[sta.top()]){
                if(map.count(nums2[sta.top()])){
                    res[map[nums2[sta.top()]]] = nums2[i];
                }
                sta.pop();
            }
            sta.push(i);
        }
        return res;
    }
};
```

③下一个更大的元素

数组此时是环形的。

[503. 下一个更大元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-ii/)

处理环形数组，将两个数组拼接在一起就行。

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        if(nums.size()==0) return {};
        vector<int> res(nums.size()*2,-1);
        vector<int> new_nums(nums);
        for(int x:nums){
            new_nums.push_back(x);
        }
        stack<int> sta;
        for(int i=0;i<new_nums.size();i++){
            while(!sta.empty()&&new_nums[i]>new_nums[sta.top()]){
                res[sta.top()] = new_nums[i];
                sta.pop();
            }
            sta.push(i);
        }
        vector<int> new_res(res.begin(),res.begin()+nums.size());
        return new_res;
    }
};
```

### 18、贪心算法

#### 18.1 跳跃游戏

**贪心的本质是选择每一阶段的局部最优，从而达到全局最优**

[55. 跳跃游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game/)

```cpp
// 方法一自己的求解方法：
class Solution {
public:
    bool canJump(vector<int>& nums) {
        vector<int> rec(nums.size(),false);
        rec[0]=true;
        for(int i=0;i<nums.size();i++){
            if(rec[i]){// 只有当前能够到达我才往下继续进行操作
                int num = nums[i];
                for(int j=1;j<=num;j++){
                    if(i+j<nums.size()){
                        rec[i+j]=true;
                    }
                }
            }
            if(rec[nums.size()-1]) return true;// 添加剪枝操作
        }
        return rec[nums.size()-1];
    }
};

// 利用贪心的思想来看待问题
class Solution {
public:
    // 利用贪心的思想来做
    // 只要跳跃的最大范围大于尾部的索引就行
    bool canJump(vector<int>& nums) {
        if(nums.size()==1) return true;
        int max_step = 0;
        for(int i=0;i<nums.size();i++){
            if(i<=max_step){
                max_step = max(max_step,i+nums[i]);
            }
            if(max_step>=nums.size()-1) return true;
        }
        return false;
    }
};
```

#### 18.2 跳跃游戏II

[45. 跳跃游戏 II - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game-ii/description/)

从开头到结尾索需要跳的最小次数

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        if (nums.size() == 1) return 0;
        int curDistance = 0;    // 当前覆盖最远距离下标
        int ans = 0;            // 记录走的最大步数
        int nextDistance = 0;   // 下一步覆盖最远距离下标
        for (int i = 0; i < nums.size(); i++) {
            nextDistance = max(nums[i] + i, nextDistance);  // 更新下一步覆盖最远距离下标
            if (i == curDistance) {                         // 遇到当前覆盖最远距离下标
                ans++;                                  // 需要走下一步
                curDistance = nextDistance;             // 更新当前覆盖最远距离下标（相当于加油了）
                if (nextDistance >= nums.size() - 1) break;  // 当前覆盖最远距到达集合终点，不用做ans++操作了，直接结束
            }
        }
        return ans;
    }
};
```

#### 18.3 任务调度器

[621. 任务调度器 - 力扣（LeetCode）](https://leetcode.cn/problems/task-scheduler/)

解决方法优点类似于脑筋急转弯。

[leetcode621. 任务调度器_2021dragon的博客-CSDN博客](https://blog.csdn.net/chenlong_cxy/article/details/125562271?ops_request_misc=%7B%22request%5Fid%22%3A%22169657725416800188552770%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169657725416800188552770&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-125562271-null-null.142^v94^chatsearchT3_1&utm_term=leetcode621&spm=1018.2226.3001.4187)

```cpp

class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        if(n==0) return tasks.size();
        vector<int> table(26,0);// 26个英文字母
        for(char x:tasks){
            table[x-'A']++;
        }
        sort(table.begin(),table.end(),greater<int>());
        int max_exec_time = table[0];
        int index=0;
        while(index<26&&table[index]==max_exec_time){
            index++;
        }
        int res = max((int)tasks.size(),(max_exec_time-1)*(n+1)+index);
        return res;
    }
};
```

#### 18.4 根据身高重建队列

[406. 根据身高重建队列 - 力扣（LeetCode）](https://leetcode.cn/problems/queue-reconstruction-by-height/)

先将身高较高的排列好，再排列身高较低的就可以达到。

```cpp
class Solution {
public:
    // 根据身高从大到小排序
    // 身高相同的,k值小的排在前面
    static bool cmp(vector<int> v1, vector<int> v2){
        if(v1[0]==v2[0]) return v1[1]< v2[1];
        return v1[0]>v2[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        // 每一步都达到局部最优，最终达到全局最优
        sort(people.begin(),people.end(),cmp);// 按照前面顺序排序好之后
        vector<vector<int>> res;
        for(int i=0;i<people.size();i++){
            int position = people[i][1];// 表示前面有几个人大于或者等于他
            res.insert(res.begin()+position,people[i]);
        }

        return res;
    }
```



### 13、其他面试问题

#### 13.1 求解点到直线的距离

```cpp
# include<iostream>
struct point
{
	double x;
	double y;
};
// 两个点定义一条线条
struct line {
	point p1;
	point p2;
};

double distance(point p1, point p2)
{
	return std::sqrt(std::pow(p1.x - p2.x, 2) + std::pow(p1.y - p2.y,2));
}

double distance_of_point_to_line(point p, line line)
{
	// 如果线段为点的话直接计算两点之间的距离
	if (distance(line.p1, line.p2) == 0)
	{
		return distance(p, line.p1);
	}
	// 说明接下来为正常的线段，不通过斜率来计算的原因是因为通过斜率来计算的话，会存在斜率无穷大的场景，难以进行计算，因此不需要进行计算
	double r = ((p.x - line.p1.x) * (line.p2.x - line.p1.x) + (p.y - line.p1.y) * (line.p2.y - line.p1.y))/std::pow(distance(line.p1, line.p2),2);
	point foot{};// 计算在线段上的垂足
	foot.x = line.p1.x + r* (line.p2.x-line.p1.x);
	foot.y = line.p1.y + r * (line.p2.y - line.p1.y);

	return distance(foot,p);
}
```

#### 13.2  判断两线段是否是相交的

```cpp
// 首先判断以这两个直线组成的矩阵是否是重叠的，如果不重叠，则一定是不相交的
// 接着利用跨立试验来做

bool check(Node a, Node b, Node c, Node d){
    if(!(min(a.x,b.x) <= max(c.x,d.x)
     && min(c.y,d.y) <= max(a.y,b.y) 
     && min(c.x,d.x) <= max(a.x,b.x)
     && min(a.y,b.y) <= max(c.y,d.y))) 
         return 0;//所在矩形都不重叠 肯定不相交
    
    
    // 可以理解叉乘的含义
    double u, v, w, z;
    u = (c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y);
    v = (d.x - a.x) * (b.y - a.y) - (b.x - a.x) * (d.y - a.y);
    w = (a.x - c.x) * (d.y - c.y) - (d.x - c.x) * (a.y - c.y);  
    z = (b.x - c.x) * (d.y - c.y) - (d.x - c.x) * (b.y - c.y);
    return u * v < -eps && w * z < -eps;//跨立实验 解释如下 
}
```

#### 13.3 雨水相关问题

```cpp
int maxArea(vector<int> &height) {// 求解所能形成的最大面积
	int left = 0;
	int right = height.size() - 1;
	int res = 0;
	while (left < right) {
		int area = min(height[left], height[right]) * (right- left);
		res = max(res, area);
		if (height[left] <= height[right]) {
			left++;
		}
		else {
			right--;
		}
	}
	return res;
}
```







### 14、常用算法

[力扣912排序](https://leetcode.cn/problems/sort-an-array/submissions/)

#### 14.1 快速排序

先将一个元素排好序，再将剩下的元素排好序。

**你甚至可以这样理解：快速排序的过程是一个构造二叉搜索树的过程**。

也就是二叉树的前序遍历方法。

```cpp
//快速排序（从小到大）
void quickSort(int left, int right, vector<int>& arr)// 输入左索引、右索引以及数组
{
	if(left >= right)
		return;
	int i, j, base, temp;
	i = left, j = right;
	base = arr[left];  //取最左边的数为基准数
	while (i < j)
	{
		while (arr[j] >= base && i < j)
			j--;
		while (arr[i] <= base && i < j)
			i++;
		if(i < j)// 互换i j
		{
			temp = arr[i];
			arr[i] = arr[j];
			arr[j] = temp;
		}
	}
	//基准数归位
	arr[left] = arr[i];
	arr[i] = base;
	quickSort(left, i - 1, arr);//递归左边
	quickSort(i + 1, right, arr);//递归右边
}
```

添加随机快排，用于应对基本上有序的情况

```cpp
class Solution {
public:
    // 下面开始利用快速排序进行操作
    vector<int> sortArray(vector<int>& nums) {
        quick_sort(nums,0, nums.size()-1);
        return nums;
    }
    void quick_sort(vector<int> &nums, int left, int right){
        if(left>=right) return;
        // 添加随机数部分（随机快排）针对基本有序的情况降低时间复杂度
        int index = rand()%(right-left+1)+left;
        std::swap(nums[left],nums[index]);// 互换头文件
        
        
        int base = nums[left];//基准定义在左边头上
        int i = left;
        int j = right;
        while(i<j){
            while(nums[j]>=base&&i<j) j--;
            while(nums[i]<=base&&i<j) i++;
            if(i<j){
                std::swap(nums[i],nums[j]);
            }
        }
        nums[left] = nums[i];
        nums[i] = base;
        // 排列剩下的步骤
        quick_sort(nums,left,i-1);
        quick_sort(nums,i+1,right);
    }
};
```



#### 11.4 归并排序

利用递归的思想，先将数组左半部分进行排序，再将数组右半部分进行排序，最后再将两个有序的数组进行排序。其实就利用了二叉树的后序遍历的思想。

**后序遍历**

```cpp
class Solution {
    vector<int> tmp;// 只是作为一个临时的数组
    void mergeSort(vector<int>& nums, int left_index, int right_index) {
        if (left_index >= right_index) return;
        int mid = (left_index + right_index) /2;
        mergeSort(nums, left_index, mid);
        mergeSort(nums, mid + 1, right_index);
        int i = left_index, j = mid + 1;// 这是两个区间开始的索引
        int pos = 0;
        // 对于两个有序数组进行排序
        while (i <= mid && j <= right_index) {
            if (nums[i] <= nums[j]) {
                tmp[pos++] = nums[i++];
            }
            else {
                tmp[pos++] = nums[j++];
            }
        }
        // 继续将剩余的填充
        while (i <= mid) {
            tmp[pos++] = nums[i++];
        }
        while (j <= right_index) {
            tmp[pos++] = nums[j++];
        }
        // 对数组
        for (int i = 0; i < right_index - left_index + 1; ++i) {
            nums[i + left_index] = tmp[i];
        }
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        tmp.resize((int)nums.size(), 0);
        mergeSort(nums, 0, (int)nums.size() - 1);
        return nums;
    }
};
```

### 15、常见题目结果

#### 15.1 手写PID算法

```cpp
#include <stdio.h>

// 定义PID控制器结构体
class PIDController {
    float Kp;  // 比例系数
    float Ki;  // 积分系数
    float Kd;  // 微分系数
    float setpoint;  // 目标值
    
    float error_sum;  // 误差累计值
    float last_error;  // 上一次误差值
};

// 初始化PID控制器
void PIDController_init(PIDController* pid, float Kp, float Ki, float Kd, float setpoint) {
    pid->Kp = Kp;
    pid->Ki = Ki;
    pid->Kd = Kd;
    pid->setpoint = setpoint;
    pid->error_sum = 0;
    pid->last_error = 0;
}

// 计算PID控制器输出
float PIDController_compute(PIDController* pid, float input, float dt) {
    // 计算误差
    float error = pid->setpoint - input;
    // 计算误差累计值
    pid->error_sum += error * dt;
    // 计算误差变化率
    float error_delta = (error - pid->last_error) / dt;
    // 计算PID控制器输出
    float output = pid->Kp * error + pid->Ki * pid->error_sum + pid->Kd * error_delta;
    // 保存上一次误差值
    pid->last_error = error;
    return output;
}

int main() {
    // 初始化PID控制器
    PIDController pid;
    PIDController_init(&pid, 1.0, 0.1, 0.01, 10.0);

    // 模拟系统
    float input = 0;
    float dt = 0.01;
    for (int i = 0; i < 1000; i++) {
        // 计算PID控制器输出
        float output = PIDController_compute(&pid, input, dt);

        // 模拟系统响应
        input += output * dt;

        // 输出结果
        printf("input: %f, output: %f\n", input, output);
    }

    return 0;
}
```







```cpp
你好，请你帮我用C++写下述题目：
现有n个人围坐一圈，顺时针给大家编号，第一个人编号为1，然后顺时针开始报数。一共会进行x轮，每轮会从上一个轮存活的人中最后一个报数为1的人开始报数。第i轮报数从1到i+1比如第4轮报数应为1,2,3,4,5,1,2,3,...。每轮报数结束后，报数为1的人存活，取余人死亡直到最后只剩下一个人存活，请返回最后一个存活的人的编号。
一个实例如下
输入：5
输出：5
第一轮每个人的报数分别为1,2,1,2,1。编号2,4的人死亡。然后从编号5的玩家开始报数。其余两个人报数为2,3，即本轮结束后死亡最后剩余一人编号为5。
```



```cpp
我们认为，满足以下三个条件的三角形是“好三角形”。
 1.三角形的三个顶点均为格点，即横坐标和纵坐标均为整数 
 2.三角形的是直角三角形，且两条直角边平行于x轴和y轴
我们想知道，在平面中选取一个大小为n*m的矩形格点阵，可以找到多少个不同的“好三角形”?
一个示例如下：
输入：网格的行数n和列数m
输出：好三角形的个数
一个测试用例如下：
输入：2 3
输出：12
```





理想测开笔试题目

```cpp
# 1.输出给定范围内的所有素数
## 1.如何判断一个数是否是素数
bool is_prime(int value){
    if(value == 1) return false;// 1既不是合数也不是质数
    for(int i=2;i<value;i++){// 判断是否能够被从[2,n-1]的数进行整除
        if(value%i==0){
            return false;
        }
    }
    return true;
}
## 2.上面判断是否是质数的有点复杂。如果一个数不是质数，必定是两个数的乘积，这两个数通常是一个大一个小。小的小于等于根号n，大的大于等于根号n。 只需要枚举更小的范围就行。
bool is_prime(int value){
    if(value == 1) return false;// 1既不是合数也不是质数
    for(int i=2;i*i<value+1;i++){
        if(value%i==0){
            return false;
        }
    }
    return true;
}
## 3.求得多个素数的时候，用上面的方法，时间复杂度就是n*sqrt(n)。计算某个数的倍数是否为素数的时候出现了大量的重复计算
埃拉托斯特尼方法：一个数如果不是为素数，那么这个数没有数的乘积能为它。从前往后进行枚举，这个数位置没被标记的肯定就是素数，如果这个数是素数的话就将这个数的倍数标记一下(下一次遍历时就不需要再计算)。如果不是素数那么就进行下一步。这样数值越大，后面计算的次数就越小。埃氏筛的核心就是将素数的倍数确定为合数。
// 求得范围(1,n]之内的所有素数并且返回所有的素数。
vector<int> eratosthenes(int n) {
	vector<int> primes;
	vector<bool> is_prime(n + 1, true);// 全都设置为质数，索引为0没有任何意义
	for (int i = 2; i <= n; i++) {
		if (is_prime[i]) {// 如果该数是素数的话。
			primes.push_back(i);
			// 用当前素数i去筛掉所有能被它整除的数
			for (int j = i * 2; j <= n; j += i) {
				is_prime[j] = false;
			}
		}
	}
	return primes;
}

## 4.求素数的极致优化
vector<int> eratosthenes(int n) {
	vector<int> primes;
	vector<bool> is_prime(n + 1, true);

	for (int i = 2; i <= n; i++) {
		if (is_prime[i]) {
			primes.push_back(i);
		}
		for (int j = 0; j < primes.size(); j++) {
			// 防止越界
			if (primes[j] > n / i) {
				break;
			}
			// 过滤
			is_prime[i * primes[j]] = false;
			// 当i % primes[j]等于0的时候说明primes[j]就是i最小的质因数
			if (i % primes[j] == 0) {
				break;
			}
		}
	}
	return primes;
}


# 2.找出数组中的局部最大值（所有满足a[i]大于a[i-1]和a[i+1]的）
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        if(nums.size()==0) return -1;
        if(nums.size()==1) return 0;
        // 需要注意进行判断的if语句
        for(int i=0;i<nums.size();i++){
            if(i==0){
                if(nums[i]>nums[i+1]){
                    return i;
                }
            }
            else if(i==nums.size()-1){
                if(nums[i]>nums[i-1]){
                    return i;
                }
            }
            else{
                if(nums[i]>nums[i-1]&&nums[i]>nums[i+1]){
                return i;
                }
            }
            
        }
        return -1;
    }
};


# 3.冒泡排序
void buble_sort(vector<int> &nums) {
	for (int i = 0; i < nums.size() - 1; i++) {
		for (int j = 0; j < nums.size()-i-1; j++) {
			if (nums[j] > nums[j+1]) {
				std::swap(nums[j], nums[j + 1]);
			}
		}
	}
}
```

```cpp

设有
int k=10;
while(k==0) k--;

def face(n):
linux权限755代表什么意思
    
智能驾驶常用传感器包含以下哪些
A.GPS
B.激光雷达
C.超声波雷达
D.摄像头
    

```

理想笔试

```cpp
1.linux755权限
linux系统中的755权限是指所有者拥有可读、可写、可执行权限，所属组与其他用户仅拥有可读与可执行权限，无可写权限

2.以下关于算法的说法，正确的是(A)
A.通常用时间效率和空间效率来衡量算法的优劣
B.算法的时间效率取决于算法执行所花费的CPU时间
C.在算法设计中不允许用牺牲空间的方式来换取好的时间效率
D.算法必须具有有穷性、确定性等五个特性
    
3.以下说法中，关于HTTP与HTTPS说法正确的是(C)
A.HTTP与HTTPS使用的连接方式相同
B.HTTP比HTTPS更安全
C.HTTP比HTTPS页面响应速度更快
D.HTTP比HTTPS要更耗费服务器资源

4.用边界值分析法,假定1<x<10,那么x在测试中应该取的边界值是B
A. x=1, x=5, x=6, x=10
B. x=1, x=2, x=9, x=10
C. x=2, x=9
D. x=1, x=10
1 2 9 10 用边界值分析法,假定1<x<10,那么x在测试中应该取的边界值是

5.
def fact(n):
    if n == 0:
        return 1
    else:
        return n*fact(n-1)

6.在MySQL中Replace在相同的主键或者唯一键的时候相当于以下哪一个操作
DELETE+INSERT(删除原有的数据再进行添加)

7.软件测试用例包括
输入数据和预期输出的结果

8.中国高校院士
select province,count(*) as count from college group by province order by count desc limit 1;

先根据province分组，然后使用count()函数统计每个分组中所有的(即*表示)记录数，将每组的统计结果形成临时列并命名为count，然后使用order by count desc根据count列中的值对临时结果倒序排序，并使用limit 1限制只选择第一个结果。

9.压力测试是性能测试的一种
    
10.设有程序段
1
2
int k=10;
while(k==0) k--;
则以下关于此循环的说法中正确的是（C）
循环执行10次
循环是无限循环
循环体一次也不执行
循环体执行一次
    
11.算法分析的前提是(B)
A.算法必须简单
B.算法必须正确
C.算法结构性强
D.算法必须通用

12.二进制数11101转化为10进制数是29

13.以下哪项属于区分白盒测试和黑盒测试的依据C
A.是否执行程序代码
B.是否看到软件设计文档
C.是否能看到被测试源程序
D.运行结果是否确认
    
白盒测试依据于能够看到被测试的源代码，而黑盒测试则只依据于软件的功能规格和设计文档，而不需要了解程序的内部实现。
    
14.有条件自动驾驶阶段的主要特点是(C)
A.由系统完成所有的驾驶操作，驾驶者可在可能的情况下接管，在所有的道路和环境条件下驾驶
B.驾驶员和系统共同控制车辆运行，但驾驶员要负责监视车辆，当智能控制失效时，由驾驶员做出应对
C.驾驶员和系统共同控制，驾驶员负责监视车辆，当智能控制失效时，由驾驶员来做出应对
D.车辆的运行由系统控制，同时系统负责监视车辆，当智能控制失效时，系统会请求驾驶员,由驾驶员做出应对。
    
    
15.车辆动力学主要组成子系统不包含A
A.供电系统
B.传动系统
C.车轮和轮胎系统
D.制动系统
    
多选：
1.https是采用什么方式进行数据加密传输的
SSL和TLS

2.智能驾驶中常用的规划算法和控制算法包含ABCD：
A.车道保持算法
B.路径规划
C.避障算法
D.跟车控制算法
    
3.以下哪些linux命令无法创建文件CD
A.>
B.touch
C.cat
D.chmod
在Linux中，> 是一个重定向符号，用于将命令的输出重定向到文件或者设备中，或者用于创建新文件.
在Linux命令中，touch 是一个用于创建新文件或者更新文件的时间戳的命令。
在Linux命令中，cat 是一个用于显示文件内容的命令。它的名称代表 "concatenate"，但它的主要作用是将文件的内容连接在一起并输出到终端或者将它们复制到其他文件中。
    
4.若进栈序列为1,2,3,4,5,6,且进栈和出栈可以穿插进行，则可能出现的出栈序列是(ABC)
A.2，4，3，1，5，6
B.3，2，4，1，6，5
C.4，3，2，1，5，6
D.2，3，5，1，6，4
    
编程题：
1.输出指定范围内的素数

```





```cpp
关于运算符重载，下列说法正确的是 ()
A.重载时，运算符的操作数个数可以改变
B.重载时，运算符的优先级可以改变
C.重载时，运算符的结合性可以改变
D.重载时，运算符的功能可以改变
    
某二又树的先序和后序遍历序列正好相反，则该二叉树一定是 ()
A.随意节点无右孩子
B.空或只有一个节点
C.高度等于其节点数
D.随意节点无左孩了
    
在C++语言中设置虚基类的目的是 ()
A.简化程序代码量
B.优化代码复杂度
C.提高程序的运行效率
D.解决多继承造成的二义性问题
    
一个类的友元函数能够访问该类的()
A.所有成员
B.私有成员
C.公用成员
D.公用成员与保护成员
```

```cpp
给你两个数组，arr1 和 arr2，arr1中的元素各不相同，arr2 中的每个元素都出现在 arr1 中，对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和arr2中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在arr1 的末尾。
```

```cpp
```







```cpp
下列Python表达式有误的是:
A x=1,y=1,id(x)==id(y)
B x=(y=1)
C x = [i for i in range(10) if i%2==0]
D a = lambda x,y:x+y

    
4.以下关于Adam优化器的说法不正确的有几个
1.Adam 结合了RMSProp 中的思想，计算了对梯度方向的指数移动平均
2.Adam 同时更新动量的一阶矩和二阶矩
3.Adam直接使用更新后的一阶矩v_t除以二阶矩s_t作为更新梯度g_t
4.Adam中进行权重衰减不会遇到耦合到一阶矩的平均计算中

关于Python中list和tuple的区别，下列说法中正确的是
A list是可变的，tuple是不可变的
B list可以存储不同类型数据，tuple只能存储相同类型数据
C list长度大小可变，可随意增删元素，tuple长度大小固定，不可增删元素
D list可以进行索引和切片提作，tuple只能进行索引操作
    
    
以下关于python装饰器说法正确的是
A python装饰函数decorator 通常返回一个闭包，并搭配@语法糖形成装饰器
B 闭包中自由变量会在内存中消失
C @语法糖本质是将被装饰的函数作为装饰函数的参数，并将装饰函数的返回值赋给被装饰函数名
D 装饰函数既可以是普通函数，也可以是类和类的方法
```

```cpp
Given a binary tree, its preorder traversal is ABCDEFG, its postorder traversal is CBEGFDA, what is the inorder traversal()?
A.ABDCEFG
B.BCAGEDF
C.CBAEDFG
D.CBEAFDG
 
多选题，以下哪些优化方法是先固定搜索方向，然后在该方向上寻找步长()
A.牛顿法
B.列文伯格-马夸尔特方法
c.高斯牛顿法
D.最速下降法

定义两个坐标(x1,y1)和(x2，y2)之间的距离为 min(x1-x2，y1-y2)。其中|x1-x2，y1-y2|为差值的绝对值。请你对每两点之间计算距离，并找出第k小距离的值。
    为了方便表示，给你一个下标从0开始的二维数组 positions，表示点的位置。其中 positions[i]是第i个点位置(x,y)。positions[i][0]是第i个点位置的横坐标x，positions[i][1]是第i个点位置的纵坐标y。
```

```cpp
```

